### Genetics

Дженерики - аналолог шаблонов в C++. Шаблоны в Java сделать нельзя - поймем дальше.
Какая мотивация этим пользоваться? Посмотрим на код. Сейчас в Java такой код будет давать передупреждения.

```java
public class Example01 {
	public static void main(String[] args) {
		ArrayList test = new ArrayList(); // аналог vector в C++
		// в C++ это шаблонный класс, мы обязательно должны его параметризовать
		// здесь (java) можно этого не делать
		
		test.add("test");
		test.add(3);
		test.add(3.0);
		test.add((Object)2); // 2 примитивный тип, как же он скастуется к 
		// Object? Она забоксится в Integer, а потом скастуется к Object.
		
		for (int i = 0; i < test.size(); i++) {
			System.out.println(test.get(i));	
		}
		
		// так люди и писали код до Java 5
		// но им приходилось (String) test.get(i) - но тут вылетало исколючение если не могло быть каста java.lang.ClassCastException
	}
}
```

`ArrayList<String> test = new ArrayList<String>();` - хотим arrayList строк , но тот же самый код на компиляции сломается, когда мы положим число в массив строк. По большому счёту дженерики были введены для того, чтобы защитить от ошибок времени выполнения и превратить ошибки во время компиляции.

Как все реализовано в Java и почему? Хотим реализовать коллецию ровно для одного элемента.

```java
class Holder1 {
	private Automobile a;
	public Holder1(Automobile a) { this.a = a; }
	Automobile get() { return a }; 
}
```
Этот контейнер не универсален - позволяет хранить только Automobile. Какие есть идеи для того, чтобы сделать все универсальным? Хранить Object!

> Коллекция в программировании — программный объект, содержащий в себе, тем или иным образом, набор значений одного или различных типов, и позволяющий обращаться к этим значениям. Коллекция: упорядоченный тем или иным способом набор объектов, который мы можем перебирать некоторым стандартным способом (например, с помощью цикла for), по сути это опять же снова контейнер, и даже можно сказать структура с определёнными свойствами

> Коллекция позволяет записывать в себя значения и извлекать их. Назначение коллекции — служить хранилищем объектов и обеспечивать доступ к ним. Обычно коллекции используются для хранения групп однотипных объектов, подлежащих стереотипной обработке. Для обращения к конкретному элементу коллекции могут использоваться различные методы, в зависимости от её логической организации. Реализация может допускать выполнение отдельных операций над коллекциями в целом. Наличие операций над коллекциями во многих случаях может существенно упростить программирование.

> Конте́йнер в программировании — тип, позволяющий инкапсулировать в себе объекты других типов. Контейнеры, в отличие от коллекций, реализуют конкретную структуру данных. Контейнер: объект, содержащий в себе другие объекты, причём тут нет никаких других условий - что это за объекты, упорядочены ли они как-то, просто объект с другими объектами внутри

```java
class Holder2 {
	private Object a;
	public Holder2(Object a) { this.a = a; }
	public void set(Object a) { this.a = a; }
	public Object get() { return a }; 
}
```

Этот контейнер универсален - но не удобен в испольщовании и нет защиты от неверного типа данных.

```java
Holder2 h2 = new Holder2(new Automobile());
Automobile a2 = (Automobile)h2.get(); // надо кастовать
h2.set("Not an Automobile");
String s = (String)h2.get();
h2.set(1); // автоматически упаковывается в Integer
Integer x = (Integer)h2.get();
```

Надо всегда помнить, что такм лежить, то есть делать все ручками. Именно так были реализованны коллекции были реализованы до Java 5.

```java
class Holder3<T> {
	private T a;
	public Holder3(T a) {this.a = a;}
	public T get() {return a;}
	public void set(T a) {this.a = a;}
}
```

Все очень похоже на плюсы. Один класс на любой тип объекта + не требуется преобразование + защита от неверного типа данных. Казалось бы шаблоны чистой воды: пишется также, выглядит также и работает также.. ни фига не утка.

Как все устроено?
- В C++ шаблоны кмпилируются в новый клас при использовании каждого нового типа  параметка. В итоге имеем отдельный машинный код для каждого типа параметра. Типа как макрос подстановки
- В Java в скомпилированном байт-коде нет никакой информации о типе параметка. Один байт-код для всех типов параметка. Потому что, например, джавовский VectorArray уже лежит в байт-коде, а мы хотим как в плюсах. Но у нас же нет исхоного кода, поэтому плюсового механизма быть не может. У нас есть один байт код на всех, он должен быть универсальным, тогда следующий пункт, чтобы T заменить на Object. 
- ПРи компиляции вся информация о типе параметка стирается и превращается в наболее общей тип - Object, если нет дополнительных ограничений. Без ограничений реально все стирается до Object - стирание дженерик-типа.

Что же тогда случается с байт-кодом, когда мы пишем у Holder3 Automobile. Происходит следующая магия. Посмотрим как все работает (на примере ArrayList)

В байт-коде класса ArrayList написано, что он внутри себя хранит массив Object[] (а не T[]).

Этот код:
ArrayList<String> al = new ArrayList<String>();
al.add("Mama");
String tmp = al.get(0);

Преобразуется в (при компиляции):
ArrayList al = new ArrayList();
al.add((String) "Mama");
String tmp = (String) al.get(0);

Тут поменялись точки входа и точки выхода. Кто такие точки входа/выхода для дженерик типа? Точки входа - это методы класса, которые ожидают на вход тип T. Точки выхода - методы, возвращающие тип T. Это означает, что компилятор будет насильно кастовать все такие точки к типу. Это нам гарантирует, что мы не сможет передать что-то не то. Потому что произойдет ClassCasetException и мы в compile time получим ошибку. И когда мы будем что-то доставать, то авто-кастовани. Но внутри тип стерт и там на стоит object, если нет ограничений и байт-код один на всех.

Итого, в чем суть дженерика?
Придумано для того, чтобы работать с разными переменными. Могли бы написать один общий класс и параметризовать его. Но точки и выхода - кастовались.

- generic'и позволяют работать единым образом с переменными различных типов
- generic-код при компиляции теряет всю информацию о типе (T). 
- Когда компилятор это видет, то он воспринимает это как синтаксический-сахар и задача - прикастовать все точки входа и выхода. Generic-класс - обертка на классами с Object. На этапе компиляции проверяется корректность присваивания и операций.
- Для проверки корректности на этапе выполнения существуют, например, специальные коллекции.

Для внешного пользователя очент похоже на шаблоны, но под капотом лежит другая технология - это приводит к больши отличиям.

Generic-типы ге совместимы по присваиванию. Мы не можем положить List<Integer> в List<Object>. Почему? Представим, что это возможно. Вспомним, что (=) начинает указывать на объект в памяти, куда указывает правый операнд. Если это так, то в список List<Object> можно положить крокодилов. Но изначальный списко будет кастовать к Integer - все упадет. Поэтому Java говорит - нельзя.

```java
List<Integer> = new ArrayList<Integer>();
List<Object> lo = li;

lo.add("hello"); // classCasetException
Integer li = lo.get(0); 
```

Только при полном равенстве можно присвоить. Компилятор знает, что lo и li - дженерик, которое чем-то параметризованно, он же и запрещает, если типы разные.


TODO: List l - как работает?
List l = new ArrayList<String>(); - стирание информации о типе. Мы проигнорировали информацию о типе у generic класса.

List<String> l = new ArrayList(); - будем работать как с list из string. Все это нужно для обратной джавы. Row-классы, для общения с кодом Java до 5 - версии. Компилятор будет выдавать на это предупреждения. Java - язык, где принято компилироваться без предупреждения.

SuppressWargigs("unchecked") - намерено говорим компилятор подавить предупредление.

Что я не могу писать внутри generic-класса? new T(); Почему нельзя писать? Просто такой код станет new Object... мы хотели бы, чтобы там был тип, который мы попросили.. Но object к string не прикастовать.. Нельзя создать массив new T[10]; Но у нас есть грязный лайфхак (T[])(new Object[10]). Когда мы создаем массив ссылочких типов -- массив ссылок, все ссылки занимают одинаковое место в памяти, поэтому нет проблем с кастованием. Могут быть проблемы с кастованием примитивных типов. 

- невозможно создать массив параметка типа
T[] ta
Collection<T> c;
new T[10] - низя

- невозможно создать массив generic-классов
new ArrayList<List<Integer>>();
List<?>[] la = new List<?>[10] - низя..

У коллекций есть итераторы. в Java итератор - это стрелочка, которая двигается между элементами. Когда вызывается next() то возращается элемент перед стрелочкой.

```java
void dump(Collection<Object> c) { // будет работать только от дженерика с object, потому что нельзя кастовать. дженерик-типы не совместимы по присваиванию.
	for (iterator<Object> i = c.iterator(); i.hasNext();) {
		Object o = i.next();
		System.out.println(o);
	}
}
```

List<Object> l; dump(l); - работает
List<Integer> l; dump(l); - не работает

Решение 1. Писать wildcard. Нам же нужна любая коллеция. <?> - коллеция параметризованная любым классом.

```java
void dump(Collection<?> c) {
	for (iterator<?> i = c.iterator(); i.hasNext();) {
		Object o = i.next(); // i.next возвращает все что угодно, нужно его как воспринять. любой класс можно привести к object.
		System.out.println(o);
	}
}
```

О чудо, теперь в работает.

Проблема 2. Хотим сделать метод, который принимает коллецию геометрических фигур и рисует их. Казалось бы, что мы не можем написать вопросик, так как аодходят не все списки на свете. Нам нужны только геометрические фигуры, но елсли передать Shape - ОК, а вот с Circle - проблема (дженерик присваивание). Вопросик - дает широкий доступ. Нам нужно ограничение, чтобы класс наследовался от Shape. Это называется bounded wildcard. (shape или его наследники). Если интерфейс, то ключевое слово также будет extends. 

```java
void draw(List<? extends Shape> c) { // для классов и интерфейсов одно ключевое слово - extends. Нескольео интерфейсов нельзя засунуть, но можно над интерфейс, интерфейс, который наследуется от двух и более интерфейсов
	for (Interator<? extends Shape> i = c.iterator(); i.hasNext();) {
		Shape s = i.next();
		s.draw();
	} 
}
```

```java
interface A {}
interface B {}
interface C extends A, B {}
```

Если у нас есть Collection<?> куда кастуются точки входа и выхода. Точки выхода кастуются к Object. К чему кастуются точки входа? Что можно положить в коллецию от вопросика? Collection<?> ничего не позволяет передать в точки входа, кроме одной едиснтвенной сущности `null` - ведь это представитель любого типа. Поэтому, когда компилятор видет коллекции с <?>, то он кастует типом, который есть виртуальной машине, (нелья написать самим) - NullType, одни представитель - null. Поэтому точки входа кастуются к этому типу.

List<? extends Shape> - выход к Shape, вход - можно ли в список кружочков положить произвольную геометрическую фигру (возможно это квадрат..)? Shape нельзя положить и любого его наследника. Положить нельзя ничего, кроме NullType (точка входа).
