

c 1:20:00

Как мы можем писать классы? Мы можем писать классы внутри классов: это называется вложенные или внутренние классы, взависимости от того, что мы напишем там.

```java
class Example {

    public class Test1 {

    }

    public static class Test3 {

    }
}
```

Классы, которые мы написали внутри с модификтором статик называются вложенными (nested-классы). А классы, у которых нет static - внутренние (inner-классы).

Что важно про них понимать? Зачем нам нужно их писать? Представим, что мы пишем коллецию, нам нужно написать итератор. Итератор должен иметь доступ к внутренностям коллекции. Какие есть механизмы, чтобы это сделать? (Можно было бы сделать данные package-private или public - но злоумышленник может добраться до них, и последнее - написать итератор прямо внутри нашей коллекции). Что хорошего? Классы, которые внутренние или вложенные, автоматические имеют доступ к полям и методам внешнего класса (? даже вложенные - статик?), так как класс внутри класса.

```java
class Exmaple {
    ...

    public class SequenceSelector implements Selector {
        private int i = 0 ;

        public boolean end() { return i == items.length;}
        public Object current() {return items[i];}
        public void next() {
            if (i < items.length) { // доступ напрямую к внешнему классу 
                i++;
            }
        }
    }

    public Selector selector() {return new SequenseSelector();} // Магия.. что же лежит под капотом? и как это работает?

    ...

}
```

Мысль 1. Когда мы говорили про компиляцию, выяснили, что при компиляции классы компилируются в отдельный файл, тут тоже это работает. Получаем два файла: Example.class, Example.SequenceSelector.

Мысль 2. В реальности в тот помент, когда мы создаем экземпляр внутреннего класса (в selectro), то экзепляр внутреннего класса привязывается к какому-то экземпляру внешнего класса.

Но если мы захотим написать такое:
```java
Example.SequenceSelector s = new Example.SequenceSelecor();

// это не сработает!
// Мы внутри нашего класса пытаем достучаться до полей внешнего класса
// Чтобы внутренний класс мог работать, он должен быть всегда привязан к экземпляру внешнего класса

// мы можем написать так
Example.SequenceSelector s = seq.new SequenceSelector();
// то есть мы явно указываем к кому мы привязываемся
```

Вложенный же класс мы можем создать без явной привязки, но данными внешнего пользоваться не можем.

Итого (разница):
- И тот и другой класс написаны внутри внешнего класса.
- Внутренний класс имеет доступ к полям, в явной форме мы можем обращаться к ним. Но чтобы мы могли так писать, экземпляр внутреннего класса обязательно должен быть привязан к экземпляру внешнего.
- Вложенные классы не привязаны к внешнему класса, они просто написаны внутри внешнего класса
- Джава неявно для всех внутренних классов в виде отдельног поля ссылку на экземпляр внешнего класса, поэтому внешний класс не может удалиться раньше!

Чтобы обратиться к экземпляру внешнего класса из внутреннего, модем написать так: `Example.this`, обратимся к полю `Example.this.items[0]`.

Если внутреннему классу поставить модификатор досутпа private, то снаружи явно создать и привязать класс не получится. Но мы можем предоставить интерфейс, чтобы через public метод получить экземпляр внутреннего класса!

Нафига нужны вложенные классы? Вложенные классы по прежнему умеют доступ к полям внешнего класса. ТО есть, если методу дадут вложенного класса дадут на вход какой-то определенный экземпляр (`Example`), то мы можем ИСПОЛЬЗОВАТЬ приватные данные, так как мы написаны внутри внешнего класса!!!

```java
class Example {
    private Object[] emts;

    public static Utils {
        public void print(Example exampleClass) {
            exampleClass.emts[0];
            // раньше было не понятно у какого класса нужно было брать поле, но сейчас мы явно говорим
        }
    }
}
```

Пометочка, во внутреннем классе мы можем назвать переменную также, как и во внешнем класса. То есть мы просто затеним предыдущую переменную, но всё также просто пишем `Example.this.наша_переменная`. Во вложенном такая же история => мы не конфлектуем с именами.

Нужно быть честным с собой! Нам эти внутренние классы нафиг не сдались в чистом виде, нам бы как-нибудь иначе их оформлять. Познакомимся с локальными классами.

**Локальный класс** - пишим внутри метода реальный класс.

```java
interface Selector {
    ...
}

class Example {
    public Selector selector2() {
        class Selector2 implements Selector {
            ...
        }

        return new Selector2;
        // то есть нам нужен класс только внутри метода, то сделаем так
    }
}
```

Локальные классы являются внутренними и внешними все зависит от **модификатора метода**! 

Сделаем ещё один шаг, ведь нам пофиг на название, потому что мы его сразу отдаем. Переходим к анонимным классам!

```java
class Example2 {
  public ClassA testFoo(String[] args) {
    return new ClassA() { // либо класс, либо интерфейс
      public int p() {
        return 5;
      }
    };
  }
}
```

Чего нет у анонимного класса? У него нет конструктора, так как не знаем, что написать. Но мы моем написать секцию инициализации. В данном случае у нас Локальный внутренний анонимный класс, если метод был бы статическим, то получился локальный вложенный анонимный класс.

```java
// Java 7
Collections.sort(list,
    new Comparator<String> {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});
```

Но 8 джава сказала нам писать так!
```java
Collections.sort(list, (String a, String b) -> {return b.compareTo(a);})

// но java и так знает, что мы сортируем строки
Collection.sort(list, (a, b) -> b.compareTo(a));
```

Эти стрелочные функции называбтся лямбдами. В 7 джава лямбды были плохи по производительности. Но в 8 джавке они появились, потому что переписали много чего. Поговорим, что же там нового появилось в 8 джава.

1. Статические методы в интерфейсах.

```java
interface Foo<T, R> {
  R apply(T t);
  static <S> Foo<S, S> identity() {
    return new Foo<S, S>() {
      @Override
      public S apply(S t) {
        return t;
      }
    };
  }
}
```

2. Ключевое слово default.

```java
interface Bar<T, R> {
  R apply(T t);
  default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
    return new Function<V, R>() {
      @Override
      public R apply(V v) {
        return Bar.this.apply(before.apply(v));
      }
    };
  }
}
```

Почему этот метод дефолтный, а не статический? Так как в статическом методе мы не имели бы ссылки на внешний apply!

Методы object нельзя переопределять дефолтными реализациями в интерфейсах.

Можно бесплатно получить ошибку компиляции! Просто имплементируем два интерфейса, где есть дефолтные реализации с одинаковым названием.

```java
interface Foo {
    default int f(int x) { return x + 42; }
}

interface Bar {
    default int f(int x) { return x * x; }
}

class FooBar implements Foo, Bar {
    // @Override // not required
    // public int f(int x) {
    //     return Bar.super.f(x);
    // }

    @Override // required
    public int f(int x) {
        return x * x;
    }
}
```

@Override - компилятор проверь, пожалуйста, что метод действительно является виртуальным.

```java
interface Foo {
  default int f(int x) {
    return x + 42;
  }
}

class Bar {
  public int f(int x) {
    return x * x;
  }
}

class FooBar extends Bar implements Foo {}
// OK, реализация Bar выиграла!

```

3. (с 9 java) появилась возможность писать приватные методы. (общую функциональность вынести в приветные методы)

Интерфейсы задают открытыю сущность, чтобы вызывать их у экземпляров классов, реализующих их. private методами никто не сможет воспользоваться: ни класс реализующий этот интерфейс, ни снаружи (идеалогия не ломается). protected - часть мест, где можно вызывать, и где нельзя - ломается идеалогия.

**Функциональные интерфейсы** - интерфейсы с единственным абстрактным методом, у него может быть куча статических, константы.

```java
Function<T, R> / R apply(T t);
BiFunction<T, U, R> / R apply(T t, U u);
Consumer<T> / void accept(T T);
Runnable / void run()
Callable<T> / T call()
```

`@FunctionalInterface` - интерфейсы с единственным абстрактным методом называются функциональными и помечаются аннотацией - она НЕ ОБЯЗАТЕЛЬНАЯ

Лямбда-функции - компатный синтаксис для инстанцирования функциональный интерфейсов.
- Компилятор сам выводит типы
- Фигурные скобки не нужны, если внутри одно выражение

Каким образом лямбда позволяет инстанцировать? В 7 джава каждая лямбда создавала новый класс - было грустно..

Для пользователя лямбды кажутся синтаксическим сахаром, но внутри это не так..

Примеры:
```java
BiFinction <String, Long, String> f = (String s, Long v) -> s + v;
BiFunction<String, Long, String> f = (s, v) -> s + v;
Function<String, String> f = s -> s + s;
Callable<String> f = () -> "!";
Consumer<String> c = s -> {System.out.println(s);};
```

```java
default <V> Function<V, R> compose(Function<V, T> before) {
    return (V v) -> Bar.this.apply(before.apply(v));
}

default <V> Function<T, V> andThen(Function<R, V> after) {
    return (T t) -> after.apply(apply(t));
}
```

Для листов появился метод `forEach` он ожидает Consumer на вход.

Collection.removeIf, принимает Predicate<T, Boolean>;
List.replaceAll ...