Давайте учиться программировать! Java - это чистый ООП язык, тут все происходит внутри классов. Метод main как в плюсах должен присутствовать, когда стартует программа, но в отличие от плюсов, где он пишется снаружи, тут он находится внутри.

Так как мы должны запускать метод main без создания класса, то у него стоит модификатор static. 
Отличия от плюсов: классы, которые мы объевляем, они могут быть публичными, приватными и другие модификаторы; кода возврата нет, так как код возврата нужен ОС, а мы внутри виртуальной машины, поэтому ОС вернется результат работы виртуальной машины. В аргументах Main в Java мы получаем массив строк, а в плюсах счетчик и массив указателей. В джаве массивы - объект, у него есть поле длины.

 Java Coding Conventions: правила именования (классы с большой буквы, константы большими буквам), camel case, snake_case только для const.
 
 Название файла должно коррелировать с его содержанием. public class NAME должен находится в файле с названием NAME.java (внутри файла только один публичный класс).
 
 Помимо комментариев в Java есть Java Doc (у них можно попросить документацию). Дальше приводится код с HelloUsers.java (там все реально очев). В следующем примере вместо перебора индексов используется foreach.
 
```
for (String str : args) {
	...
}
```
 
 Компилятор Java традиционно вызывается с помощью команды javac (java compiler). Результатом являются откомпилированне байткода классов (*.java -> *.class). Для непубличных классов из файла будут созданы свои class-файлы, поэтому не стоит создавать непубличные классы с одинаковым именем.
 
 Когда наш основной класс не самодостаточен, то нужно объяснить компилятору, где взять эти дополнения.
 Мы должны указать, где находятся исходные тексты классов, любо компилированные версии. 
 --classpath - системная переменная, в которой перечисленны пути, где нужно искать классы. Когда выпишем этот флаг, то можешь добавить свои классы, например:
 
 javac --classpath library.jar -d classes MyClass.java
 
 Jar - zip архив со специальной структурой.
 
 ClassPath:
 - Все используемые классы должны быть доступны в путях, содержащихся в classpath
 - Всегда содержит классы стандартной библиотеки (jre/lib/rt.jar)
 - По умолчанию содержит текущую директорию "."
 - Задается как список директорий и/или JAR-файлов
 - Разделитель списка ":" в Unix/Linux/Mac OS X
 - ";" в Windows
 
 После компиляции мы очевидно хотим запустить нашу программу, нам нужно отдать её виртуальной машине. Виртуальная машина принимает на вход имя класса, а не имя файла. 
 
 java MyClass, MyClass ищется в --classpath: проходим по всем содержимому classpath и пытаемся среди содержимого найти нужный файл (MyClass.class), когда файл находится, то проверяется верно ли, что внутри этого файла есть метод main с сигнатурой public static void main(String[]) <- если все ок, радосно прыгаем в точку входа программы и работаем.
 
 В Java by design убрали перегрузку операторов, поэтому оператор [] нельзя перегрузить для какого-то класса, для строки он не перегружен, поэтому str.charAt(i). Это сделано так, потому что по мнению разработчиков перегрузка операторов снижает читаемость кода, плохо понятно когда какой метод вызывается.
 
 Там ещё внимание обращается на то, что в функции класса Parse передается строка String str без указателей, без ссылок. Всё это потому что String - ссылочный объект, дальше это обсудим.
 
 Package похож на namespace в плюсах. Вообще договориваются, чтобы название пакета - это обратное доменное имя, автор, описание проекта, какой-то модуль. Значение в package также означает, где должен находится файл.
 
 package ru.spbau.kuznetsov.test01.parser
 ru/spbau/kuznetsov/test01/parser
 
 Все это нужно для того, когда мы захотим что-то импортировать его будет легко найти по структуре папок.
 
 В плюсах мы не пишем идентификатор доступа у каждого элемента, но в Java нужно делать у кажого.
 
 В Java нет множественного наследования, наследование происходит с помощью ключевого слова extends.
 У класса может быть конструктор - метод называется как класс, но у него нет типа возвращаемого значения (есть модификатор доступа). 
 
 TODO: про конструктор
 
 this - это ссылка.
 
 В производных классах можно перегружать методы родительского класса. super.parse(str) - вызвает родительскую реализацию класса (если нужна реализация древнего предка, то нужно явно писать класс и метод: Parser.parse). В кодовых соглашениях Джавы написано, что не пишите this везде, где это можно.
 
 ! В Джаве все функции виртуальные, кроме статических. Поэтому не нужно писать virtual, @Override
Виртуальные функции - в целом это плохо, но вспоминаем, что в Java есть JIT, который оптимизирует код в RT, следствием является то, что мы знаем какие классы загруженны. Если производные классы не перегружали метод, то функция девиртуализируется. В ином случае они вызываются через таблицу виртуальных функций.

package ru.sbpau.kuznetsov.test01;
Когда мы пишем какой-то класс в новом пакете, то мы не можем щаиспользовать классы не из пакета по их имени, поэтому: (если новый пакет дочерний или родительский, то схема такая же!)

import ru.sbpau.kuznetsov.test01.parser.*; - импортирование всего, что есть в пакете
import ru.sbpau.kuznetsov.test01.parser.Parser; - импорт определенного класса

> Импортирование всего может привести к конфликту имен

Parser p = new AdvancedParser(3); - полиморфизм, наследование, всё "вот это вот" в чистом виде. Переменную объявляем родительским типом, инстанцируем дочерним классом. Единственный способ создания объекта - new. Parser p - ссылка. Де факто у нас происходит:
- Выделяется память под AdvancedParser
- На этой памяти вызывается конструктор от 3
- затем p начинает ссылаться на эту область памяти

p.parse(args[i] + 1); - полиморфизм, все функции виртуальны, поэтому когда вызывается метод parse, мы смотри ни на то какого типа переменная p, а смотрим на то, чем  она действительно инстанциорованна. Следовательно paese вызывается у AdvancedParser

## Примитивные типы

В Java всего 9 примитивныъ типов, void в том числе. Про примитивные типы важно понимать, что в отличии от плюсов, где размер примитивов, знак - это вопрос к компилятору, архитектуре. Здесь (в java) жОстко прописано про них все.

byte (1), short (2), int (всегда 4 байта), long (8 байта всегда) - это всегда так и не зависит от компилятора; float (4), double (8);

boolean занимает 1 бит? фтоооо? Но это не совсем правда) Булеан занимает эффективно 1 бит, если включить соответствующую опцию java-машины, тогда она будет хранить булевские переменные более эффективно, но с возможным накладным расходом битового сдвига для вычисления значения. Это больше бля экономии памяти.

char - 2 байта! Сейчас все поймем.
Там есть ещё void, но про него потом.

Ссылочные типы - все типы, кроме 9-ти перечисленных, называются ссылочными. Они же являются объектами и передаются по ссылке.

Dog thisDog = new Dog("Sparky"); - память, конструктор на памяти, готовый объект.
Dog thatDog = thisDog;  - thatDog указывает ТУДА ЖЕ, куда указывает thisDog
thatDog.setName("Wolfie") - thisDog и thatDog теперь будут хранить Wolfie

Все классы на свете наследуются от java.lang.Object. Все они явно или не явно наследуются от object. Если явно не писать extends, то компилятор сделает это за нас: будет наследован от Object наш класс. 

Зачем это нужно? Это нужно для того, чтобы во всех классах в реальности появилось несколько методов, которые отдабтся от Object:
- String toString() - все обхекты модно приводить к строке (типа для вывода)
- int hashCode() - как считать хеш-кол объекта
- boolean equals(Object obj) - используется для сравнения. Так как нет перегрузки операторов, а сравнивать очень хочется, поэтому у == другой эффект, поэтому нужно делать equals.

Самый простой примитив - boolean. 
- Его можно получить <,>,<=,>=, !=
- литералы: false, true
- нет преобразования между boolean и другими примитивными типами (в обе стороны). Как следствие нельзя писать

```java
int x = 3;
if (x) { 	// низя 
	...
}
```

Почему так нельзя? В то время, когда разрабатывался язык, была популярна ошибка `if (x = 3) {}`. Чтобы так люди не писали, убрали конвертацию

С булиан можно делать логические операции 
&& 	&	&=
||	|	|=
^		^= 
!

&& и || - вычисление по сокращенной схеме
& и | - вычисление по полной схеме

В чем суть то? Когда у нас есть (..) & (..) мы уверены, что выполнется и правая, и левая скобка не взависимости от левого аргумента. А &&, когда левый аргумент равен false, то справа ничего вычисляться не будет, вернется false. Важно следующее, в java строго регламентирован порядок вычисления аргументов, в плюсах не так. Во второъ есть четкое разделение между ленивым и не ленивым вычислениями. 

```java
boolean a = true;
boolean b = false;
boolean c = (a ^ b) == (a != b); // true
boolean d = c ^= !b || a; // d = true, c будет уже false!

int m = 0;
int n = 10;
if (m != 0 & n / m >= 1) {} // все сломалось в нуле..
```

Зачем же это может понадобиться? Верификация кода, допустим, вызывая функции, которые должны выполниться.

Вопрос из чата!
- new - создает элементы на куче
- локальные переменные - создаются на стеке (очев емае - АКОС же!!)

Тут на поле боя выходит класс обертка для примитивного типа boolean. На данный момент не переживаем из-за названия "класс обертка" - АМ все расскажет. Для нас на текущий момент - это полезный класс, который содержит разные методы, позволяющие эффективно работать с примитивными типами.

- boolean parseBoolean(String)
- String toString(boolean)

```java
// чудо-код
boolean b = Boolean.parseBoolean("false");
String str = Boolean.toString(b);
```

Тип char.. много вопросов!

char - беззнаковый тип, занимает 16, хранит от 0 .. 2^16 - 1
- представляет номер символа в кодировке Unicode - это фу.. 
Unicode - это не кодировка, это таблица символов, где каждому символу соответствует номер. Кодировка - это способ отображения какого-то символа в последовательность битов/байтов.

Например, кодировка, котрая позволяет хранить Unicode символы, UTF-8/16. Char - номер в таблице. Правда в Unicode больше символов, поэтому char - это подмножество таблицы.

Если выводить эти char в файл, то взависимости от кодировки, они будет храниться по разному (1, 2, 4 байта и так далее). Задабтся в 'a'; '\u78bc'; спецпоследовательности  '\t', '\n', '\"', '\\', '\r', '\''.

Так как char - номер символа, то есть свободная конверация между числом. Числовой тип (разрешенный) <-> char.

Так же есть класс-обертка - Character
- boolean isLowerCase
- boolean isUpperCase
- boolean isDigit
- boolean isWhiteSpace
- boolean isLetter
- char toLowerCase
- char toUpperCase
- int getNumericValue - если цифра, то вернется её значея, чтобы не вычитать '0'

Целочисленные типы.

Размер фиксирован и одинаков для всех платформ. Все тиаы знаковые, беззнаковых вариантов нет (не было до появления Java8).

Дессятичное число: 123
Восьмеричное: 0123
Шестнадцатеричное: 0x123
Двочное: 0b101 (с Java 7)
С подчеркиванием: 123_456_789 (с Java 7)
с суффиксом L для long (для явного указания типа)

Деление целых чисел дает целое число: a == (a / b) * b + (a % b)
деление на ноль - исключительная ситуация, бросается ArithmeticEception

переполнение не является исключительной ситуацией, лишние старшие биты просто выкидываются 

Byte, Short, Integer, Long
методы статические: toString, parseTypename(String); parseInteger, parseShort..
константные ститические поля: MIN_VALUE, MAX_VALUE

Вещественные числа:
как и везде.. 
Особые случаи:
- деление полодительного числа на 0 дает +inf
- деление отрицательного числа на 0 дает -inf
- деление на 0 на 0 дает NaN
- переполнение дает +inf или -inf, в зависимости от направления
- любая арифметическая операя с Nan дает NaN
- NaN != NaN

Преобразование!

Явные, неявные преобразования у нас в руках. Неявное преобразование возможно в случаях:
- Преобразования целочисленных типов в более емкие (byte -> short -> int -> long)
- Преобразование char в int, long. В short нельзя перевести, так как short - знаковый.
- Преобразование целочисленные типаов в типы с плавающей точкой (возможна потеря точности). Может не поместиться полностью (АКОС рулит)

Явное преобразование:
- Операторы явного приведеня: (int), .., (typename). Но есть нюансы
- При приведение более емкого целого типа к менее емкому старшие биты просто отбрасываются
- При приведении типа с плавающей точкой к целому типа дробная часть отбразывается (никакого округления)
- Слишком большое дробное число при приведении к целому превращается в MAX_VALUE, MIN_VALUE
- Слишком большой double при приведении к float превращается в Float.POSITIVE_INFINITY или Float.NEGATIVE_INFINITY

ВОт сейчас мы пообсуждали классную штуковину, а что делать, когда есть сравнение или арифметическая операция, выражение с двумя операндами. 

Привычислении выражения (a @ b) аргументы a и b преобразовываются в числа, имеющие одинаковый тип:
- если одно из чисел double, то в double
- иначе, если одно из чисел float, то float
- иначе, если одно из чисел long, то в long
- иначе оба числа преобразуются в int!

ВАЖНОЕ следствие! Арифметические операции над byte, short, char имеет тип int, поэтому для присвоения результата обратно в byte, short, char понадобится явное приведение типа

Поэтому такой код не скомпилится
```java
char c;
c = c + 1;
```

- Сокращенная запись var @= expr раскрывается в var = (typename) (var @ expr) <- тут может быть проблема с потерей байт

Всё-таки почему обертки? Boxing, unboxing - иеханизмы в Java. Они позволяют писать `Integer a = 5;`.
Boxing - автоматическое преобразование примитивного типа в соответствующий объект класса-обертки.
UnBoxing - обратное преобразование
`int b = a;`

a + b (Integer + int), перегрузки нет, поэтому плюс нельзя выполнить с Integer. Будет выполнене UnBoxing для a.
a < b - unboxing

Integer a = 1000;
Integer b = 1000;

a == b <- false. Если Java не может выполнить какое-то действие между ссылочным и примитивным типом или двумя ссылочными, двумя примитивными, то она их распаковка. 

a < b - распаковка a и b

a == b - между integer есть такое действие, ссылочные типы на равенство. они сравниваются по ссылке (на месте куда ссылаются). 

Маленькие значния Integer действительно могут давать верное значние при ==, потому что JVM кеширует значение. Этим можно управлять через ключи запуска JVM, но по умолчанию -128 до 127 кешируются.

но если сделать new Integer(1), то эффект такой же как и boxing 1000.

В Java есть два способа сравнивать объекты на равенство, == и метод equals 
- == используется для примитивных типов
- для объектов == - сравнение ссылок
- Для остального надо использовать метод equals. Кроме того, метод hashCode служит (теоретичнски) для той же цели. Хорошим тоном считается переопределть его, если вы переопределили equals.
- Золотое правило сравнения: если после инициалищации неких объектов a и b выражение a.equals(b) вернет true, то a.hashCode() == b.hashCode()

Как не нужнл писать: пихать везде обертку
```
for (Integer j = 0; j < 1000; ++j) { // boxing с примитивовм при инициализации, сравнение с примитивом (unboxing), j++ <=> j = j + 1, где j - ссылочнй объект, 1 - примитив <=> unbox, box... с 128 до 999 кушается много памяти, так как объекты не кешируются, объекты создаются. 
	for (Integer i = 0; i < 1000; ++i) {
		sum += j * 1000 + i;
	}
}
```

Раньше этот код работал в 10 раз дольше, чем с int. Но сейчас это не так, потому что JIT очент умный. Оптимизации происходят на статистике, нужно прогнать цикл несколько раз, понять что-то про него, а затем оптимизировать, поэтому замена на int произойдет не сразу.

Передача аргументов
- Передача по ссылке подразумевает передачу ссылки на объект. В этом случае реализация метода потенциально модет модифицировать переданный объект (например состояние).
- В случае передачи по значению параметр копируется. Изменения параметра не будет заметно на вызывающей стороне.
- В Java объекты всегда передаются по ссылке, а примитивы по значению.

Дальше идет "АКОС", рассказывабт про то, что параметры кладутся на стек, а локальные переменные тоже на стеке.. (пример с int)

Потом пример с Integer, String, .. создается в куче объект, на который ссылается переменная. Затем её закидывабт в функцию, где она также ссылкается на это облачко. Потом новой ссылке дают новое облачко. При выходе из фунции у старой локальной переменной ничего не поменялось. (см. презентацию)

Как поменять значение в ссылке то? Никак) Подобие в виде класса с разными полями, потому что можем изменить поле. То есть нужны модифицирующие методы, доступ к полям. В Java нельзя написать swap


 
