Всем привет! Говорим про многопоточное программирование!

Многопоточность в Java была с рождения, это важно. Частично многопоточка плюсов была списана с джавы. Конечно, не все так гладко, многопоточность в Java была не очень, но в итоге они придумали крутую модель памяти, которую пытаются реализовать много других языков программирования. 

#### Введение

Разница между многопоточным и многопроцессорным программированием: у потоков общая память, а у процессов изолированная память. Но потоки могут менять один и тот же кусок памяти, что может привести не приятным последствиям.

- Каждый поток имеет свой стек вызовов
- У потоков общая память
- Java-поток != поток в ОС (в стандартной реализации они сопоставлены один к одному, но в общем случае - это не обязательно)

На железе есть процессор, который все исполняет. Раньше были одноядерные процессоры, где исполнялся один поток, но сейчас многоядерные процессоры, но в любом случае количество ядер меньше, чем количество поток, которые работают в рамках операционной системы. Но есть механизм - планировщик потоков, который определяет какой поток будет сейчас исполнятся на процессоре: убирает и загружает другой. Но что это значит? У потока есть стек, это загружается в ядро и инструкции, которые надо выполнять. Убирать - созранить стек, запомнить инструкцию и куда-то сохранить. Это какой-то долгий процесс, весь перформанс зависит от планировщика. Это вообще гарантирует ОС.

- У JVM свой планировщик потоков, который не зависит от планировщика операционной системы под которой работает JVM. То есть можно писать одноядерную программу на одноядерном компьютере и она будет прекрасно работать. То есть потоки джавы не потоки ОС.

- В Java есть два вида потоков: потоки-демоны и пользовательские потоки. JVM завершает выполнение программы, когда все пользовательские потоки завершат свое выполнение. Демонов насильно убьют (это служебные потоки).

Метод main - соответственно один поток (окончание работы main != завершение программы). Давайте учиться рожать новые потоки. 

Класс Thread - поток. Позволяет создавать потоки и производить операции с ними. Интерфейс Runnable - сущность, которая может быть запущена (`public void run();`).


```Java
// Создание
Thread t = new Thread(new Runnable() {
    public void run() {
        System.out.println("Some string");
    }
});

// Запуск
t.start();
```

Можно перегрузить Thread, но это не рекомендуется. В реальности часто мы создаем несколько потоков с одинаковым набором действий (список задач) (передаем один Runnable). Вторая мысль если мы создаем наследника потока, то наследовать его не откого не получится (нет множественного наследования) (мы себя ограничиваем).

```Java
Thread t = new Thread() {
    public void run() {
        System.out.println("Hello");
    } 
};

t.start();
```

`Thread(String)` - для удобства, чтобы как-то по имени мониторить поток, общаться между потоками, служебная информация.

Поток запускается `.start`! Если написать `.run`, то это вызовется метод, но в том же потоке.

```Java
public class Starter {
    public static void main(String[] args) {
        NameRunnable nr = new NameRunnable();
        Thread one = new Thread(nr);
        Thread two = new Thread(nr);
        Thread three = new Thread(nr);

        one.setName("one");
        two.setName("two");
        three.setName("three");

        one.start();
        two.start();
        three.start();
    }

    class NameRunnable implements Runnable {
        @Override
        public void run() {
            for (int x = 0; x <= 3; x++) {
                System.out.println("Run " + Thread.currentThread().getName() + ", x = "+ x);
            }
        }
    }
}
```

Строки при выводе могут быть перепутаны, но в рамках одного потока все идет последовательно. Буквы не могут быть между собой перепутаны из-за внутренней реализации `println`.

У потока есть идентификатор (id), имя (name), приоритет (priority), поток-демон.

В качестве визуализации планировщика потоков представим, что поток это тетрадка, в которой записан набор инструкций, который поток будет выполнять. Куча потоков - пачка тетрадка. Закладка в тетрадке - место где мы остановились.

Планировщик потоков с какой-то переодичностью (эврестической), просматривает эту пачку сверху-вниз в попытке найти первый поток, который может выполнятся (не обязательно самый верхний). Берет тетрадку, если не может выполнятся, то кладет её вниз, если может, то из тех, кто-то долго выполняется кладет вниз в пачку, сделав закладку. Приоритет - модификация очереди с приоритетами, то есть потоки у которых приоритет выше - им чаще достается процессорное время, но формульной зависимости нет. Чем выше - тем чаще, все ОС понимают по разному. 

Состояние потока возвращается методами `int getState()`, `boolean isAlive()`.

getState - NEW, RUNNABLE (+), BLOCKED (+), WAITING (+), TIMED_WAITING (+), TERMINATED

(+) - isAlive -> true;

```
         Waiting / blocking [Blocked, waiting, timed_waiting]
          |            ^
          v            |
New -> Runnable <-> Running -> Dead
``` 

New - просто создали объект.
Runnable - готов к выполнению, лежит в пачке, откуда можно взять потоки.
Когда планировщик потоков загрузить наш поток на ядро, то мы перейдем в состояние Running.
Когда планировщик решит, что нам нужно приостановится работать, он переведет нас в Runnable.
Когда стек закончился, мы закончили свою работу, переходим в Dead.

Мы можем попросить поток заснуть на какой-то время, он перейдет в состяние time waiting, когда он выспится, то перейдет в Runnable. Waiting / blocking - то, что мешает выполнятся потоку: блокировка по mutex, IO, ...

В верхнюю вершину можно попасть только из состояния Running. Невозможно попасть в Running из любого места, отличного от Runnable.

Для JVM Runnable и Running это одно и тоже, то есть getState отличит не получится. Почему? Время которое поток проводит на процессоре - маленькое. Мы то можем получить информацию о тех, кто выполняется (спросить на ОС), но в моменте получив информацию, она сразу может стать неактуальной, так как поток могут уже выгрузить.

Blocked - например IO, так как мы по ному блокируемся. Разблокируемся, когда нажмут ENTER.

Взаимодействие потоков
- Создать потоков
- Запуск потока - start
- Ожидание оканчания потока - join
- Прерывание потока - interrupt
- Засыпание потока - sleep
- Переключение потоков - yield

Thread.sleep(millis, nanos) - переводит в TIMED_WAITING
TimeUnit.SECONDS.sleep(secs)
- SECONDS
- MILLISECONDS
- MICROSECONDS
- NANOSECONDS
- DAYS
- HOURS
- MINUTES

! Все методы кидают InterruptedException.

Важно понимать, что все эти методы являются статическими, поэтому влияют они только на текущий поток (на котором выполяются).

Команда Thread.yield() (статический) нужно для того, чтобы ПРЕДЛОЖИТЬ планировщику потоков убрать нас с состояние Running в состояние Runnable. 

То как часто потоки будут на ядре задается приоритетом.

Константы
Thread.MIN_PRIORITY - 1
Thread.NORM_PRIPRITY - 5
Thread.MAX_PRIORITY - 10

FooRunnable r = new FooRunnable();
Thread t = new Thread(r);
t.setPriprity(8); // 1-10, рекомендуется использоваться константы
t.start();

Но зачем нам нужен yield()? Бывают ситуацию, когда нам выгодно, чтобы потоки одновлеменно закончили свою работу. Представим, что один поток убежал далеко вперед, нам выгодно пердать управление другим, чтобы они его догоняли. Но общая идея - если мы не уверены, что она нам нужно - НЕ пиши её. Это нужно для тонкой настройки перформанса.

Например, два потока что-то пишут/читают парарлелльно, а потом меняются. Выгодно было бы, чтобы один из них не простаивал, поэтому yield в помощь. 

- Ещё раз. Приостановить работу другого потока нельзя.

join не статически метод, t.join() - останавливает текущий поток, пока t не закончит свою работу. Считаем интеграл, 4 потока считают свой промежуток, главный поток ждет частичных сумм.

t.join() - кидает InterruptedException. Ещё в аргументы можно подать миллисекунды и наносекунды (максимальное время ожидания).

Единственная возможность повлиять на другой поток - вызвать у него метод interrupt(). Это нужно для того, чтобы РЕКОМЕНДОВАТЬ потоку завершить свою работу. Если поток в Runnable/Running, то метод interrupt никак на него не повлияет. Если он находился бы в одном из методов, который кидает InterruptedException (sleep, join, ..), то в тот момент, когда мы придем прерывать его, то метод выкенет InterruptedException.

isInterrupted() - проверить флаг прерывания
interrupted() - проверить и сбросить флаг прерывания

```java
class Worker implements Runnable {
    public void run() {
        try {
            while (!Thread.interrupted()) { // просил ли кто-то прервать наш поток, но можем проигнорировать

            // могут быть методы, которые переводят в верхний кружочек, если нас кто-то остановит, то блокирующая операция бросит InterruptedExeption

            }
        } catch (InterruptedException e) {
            // честное в джаве место, где можно бы написать пустой catch
        }
    }
    // Рекомендация - не путь к действию выключения
}
```

У Thread есть deprecated метод destroy (плохой, небезопасный).

#### Синхронизация кода

Зачем нужны блокировки. Представим себе два чудесных потока, которые делают `i++`, i лежит в общей памяти.

```java
T_1
for (10)
    i++

T_2
for (10)
    i++
```

i++ - read i, i + 1, write i

Получить 10 - делаем все вместо, читаем, прибавляем, записываем (почти синхронно)
Получить 9 - первый поток заходит на последнюю итерациию, когда второй только что записал 8, затем первый читаем 8 прибавляет 1 и ждет на запись, второй завершается, а первый записывает 9.
Получить 2 можно по примерной схеме.

от 2 до 20 можем получить в таком коде. Чтобы таких side-effect не было можем по объекту получать блокировку.

```java
synchronized (o) { // получение блокировки

} // снятие блокировки (автоматическиое снятие, блокировка будет отдана не взависимости от исключений, главное покинуть frame стека с блокировкой )
```

Если кто-то попробует взять блокировку на объект с блокировкой, то он уйдет в blocked.

```java
T_1
for (10)
   sync (x) // теперь i++ работает целиком
   // можно брать блокировку по любому объекту, главное чтобы был один и тот же
   // объектом блокировки может быть что угодно
    i++

T_2
sync (x) // цикл отработает целиком, если сюда переставить
for (10)
    i++ // изенения в локальных кешах
```

synchonized - не бросает interrupted exception, единственный способ вывести его из blocked отдать блокировку на требуемый объект. 


```java
public void synchronized foo() {

}
// почти эквивалетно, но первый способ лучше оптимизируется JIT
public void foo() {
    synchronized(this) {

    }
}

// У статик методов вместо this пишут Example.class
```

yield, sleep, join удерживает все свои блокировки!

Паттерн проектирования производитель-потребитель
- Один поток производит данные, второй их потребляет
- Несколько потоков потребляют данные и несколько потоков потребляют данные
- Данные монут хранится в очереди (не) ограниченного объема

```java
public void set(Object data) {
    while (true) { // тут нет блокировки, так как будет один производитель, который возьмет блкировку
        synchronized (this) { // блокировка нужна, чтобы два производителя не положили одновременно данные.
            if (this.data == null) {
                this.data = data;
                break;
            }
        }
    } // брать в while блокировку - плохо
    // когда мы уходим в blocked - и выгружаем стек, регистры, инструкции, а потом придется загружаться - все заново

    // это паттерн активное ожидание
}
```

#### Мониторы и условия

- wait - наш поток из Running перейдет в waiting
- notify - разбудит кого-то одного, кто ждет этот? объект
- notifyAll - разбудит всех, кто ждет этот? объект

В Джаве нечестный монитор, будет кого-угодно, а не того, кто долго ждет. Первая тетрадка, в которой написано, что он ждет.

mutex -> monitor
- При ожидании монитора (wait) блокировка с него снимается!
- При извещении поток не получает управления пока не может получить блокировку обратно
- notify и botifyAll не снимают блокировку!

```java
T1
sync (o)
    ...
    o.wait() -> из waiting в blocked, когда сделают notify по объекту
             -> ждем когда снимут блокировку

T2
sync (o)
    o.notify()
    ...

```

```java
public synchronized void set(Object data)  {
    if (this.data != null) {
        wait();
    }

    this.data = data;
    notify(); // не работает, не понятно кого будит, может разбудить
    // другого производителя, а нам нужно потребителя

    // когда нас разбудили не факт, что данные взяли, то есть мы верим, что все ОК
} 

public synchronized Object get() {
    if (data == null) {
        wait();
    }

    Object d = data;
    data = null;
    notify();
    return d;
}
```

Suspirious wakeup (внезапные пробуждения) - иногда потоки сами просыпаются.

Идиома - wait нужно писать в while!

```java
public synchronized void set(Object data)  {
    while (this.data != null) {
        wait();
    }

    this.data = data;
    [x] notify(); // если один потребитель и производитель, то ок, но если их много, то не работает.

    notifyAll(); // можем починить, так как всех разбудим сразу, не будем полагаться наудачу.
} 
```

Паттерн задание-работкини: задачу положили, работники выполнены, вернули результат клиенту (отличие с производителями-потребителями). Если выполнять задачу на коиенте, то это ударит по преформанту, так как часто будет смена контекста, поэтому давайте ограничем количество воркеров (<= количество ядер).

```java
synchronized (task) {
    synchronized (queue) {
        queue.add(task);
        queue.notify();
    }
    task.wait();
}

// если сделать два последовательных synchorinized, то можт получится так, что задача выполнится, а мы только начнем ждать, а он уже notify прислал..
```

```java
synchronized (queue) {
    while (queue.isEmpty())
        queue.wait();
    Task t = queue.get();
}

synchronized (t) {
    // process
    t.notify();
}

```

#### Java Memory Model

Модель памяти - набор правил, который ЯП дает программисту, чтобы тут мог что-то делать. Питон дает жесткие гарантии, одновременно исполняется только один поток, потому что он берет глобальную блокировку на весь интерпретатор, от этого страдает производительность.

В Java 5 была написана хорошая модель памяти, на которой многие современные ЯП построены. 

Out of the air - гарантия, что значения не берутся из воздуха. В плюсах этого до сих пор нет.

```java
a = 0

T1
a = 1
a = 2

T2
while
    s.o.p(a)
```

Модель памяти Java гарантирует, что кроме 0, 1, 2 ничего другого не будет. В плюсах же может выпасть 42 или что-нибудь хуже.

Основные свойства
- Атомарность - операция, в которой мы не можем увидеть промежуточного состояния. Видем только до и после. Блокировки, локальный подсчет где-то на низком уровне.
- Операции над всеми типами кроме long и double являются атомарными. (i++ - это 3 операции, но write, read, add, get link, set link - атомарны по отдельности).

Почему long не попал туда, когда создавалась JMM длина машинного слова была 32, соответсвенно они гарантировали только для 32 битных значений. long и double - это много, на 64 битной системе могут быть атомарными.

```java
int a = 0;
long b = 0;

a = 1;
b = -1;

a: 0 1

b: 0 -1
0xfffff0000 // записались не все единички
.....
```

Видимость - о том, когда видим изменения, которые произошли в другом потоке. Процессор старается минимизировать обращений в память, поэтому когда мы пишем a = 1, он создает переменную в кеше ядра переменную a = 1. В какой-то момент эти изменения будут отображены в кеш более выского уровня, а затем ещё выше и только потом в оперативную память. Можно было бы все изменения выкидывать в оперативку, но это оооочень дорого. Соответственно возникает проблема, что из другого потока мы хотим увидеть изменения в другом. Для того, чтобы это гарантировать дается 3 пункта (видимость):

- После изменений поток 1 освободил блокировку, которую захватил поток 2
- После изменения поток 1 создал поток 2
- Поток 2 дождался окончания потока 1 (join)


```java

T1
sync (x) {
    a = 1;
    x++;
    b = 7;
}

T2
sync (x) { // если этот поток захватил блокировку первого потока, во время выполения первого. Он будет видеть все изменения T1

}
```

```java
int a = 0;
int b = 0;

// T1
a = 1;
b = 2;

// T2
print a b

//
0 0
0 1
1 2
0 2 // в локальном кеше реально записаны все изменения, но отобразись они не в том порядке, первым b, a ещё не отравилось
```

Упорядоченность - когда после написания кода мы отдаем его компилятору, а он точно оптимизирует наш код: удалит операции, переставит их местами. JVM тоже оптимизирует.. процессор оптимизирует..

```java
int a = 0;
a = 1;
a = 2;

// 
0 0
0 1
0 2
1 2

2 0
2 1
```

//
S.o.p(a, a) - мы так пишем
на самом деле S.o.p (read1 a, read2 a)

// операции чтения можно поменять, чтение из оперативной пмяти дорого
read1 a
read2 a
S.o.p(.. , ..)

//
Когда процессор хочет сбросить кеш в оперативную память, он не будет ждать когда это произойдет

Менеджер памяти - кеш верхнее уровня, либо отдельная сущность. Она же перекидывает их в память.

a = 1
a = 2
[.., 2, 1, ..]
Тут пришел второй поток, он не взаимодействие с RAM, он топоет в менеджер памяти. Чему равно значение a? Он просматривает начало очерди и видит элемет 2 и отдает её. Но он не может просматривать её всю. Если значения будет в конце, то он пойдет в оперативную память и вернет 0.

volatile переменные в простом объяснении:
- Операции с ними всегда происходят в общей памяти. (чтение и запись оттуда и туда). Нет проблем с видимостью
- Операции с volatile- переменными всегда атомарны
- На ссылочные объекты, volatile по ссылки, и поля обычные.

```java
class Foo {
    private static Helper helper = null;
    public static Helper getHelper() { // synchronized написать - дорого и не оправдано, самое долгое создать объект, поэтому хотелось бы по нему как-то синхронизироватся
        if (helper == null) {
            // synchronized (Foo.class) if helper == null new Helper
            // шаблон double-checked locking, но это не работает 
            helper = new Helper(); // выделение памяти, вызов конструктора, записать ссылку на память. Упорядоченности нет, выделить память, записать ссылку, а только потом конструктор... Только поля все null.. и падаем NPE..

            // не факт, что все изменения из конструктора + менеджера памяти доехали до RAM
        }
        return helper;
    }
}
```

У volatile переменных конструктор атомарный!

```java
class Foo {
    private volatile Helper helper = null;
    public Helper getHelper() {
        if (helper == null) {
            synchronized (this) {
                if (helper == null) {
                    helper = new Helper();
                }
            }
        }
        return helper;
    }
}
```

Вообще лучше так не делать, поэтому делаем так ..

```java
public class Singleton {
    private Singleton() {}

    private static class SingletonHolder {
        // пишем тут, чтобы раньше не загрузить класс
        // класс создастся только тогда, когда вызовут getSingleton
        public static final Singleton instance = new Singleton();
    }

    public static Singleton getSingleton() {
        return SingletonHolder.instance;
    }
}
```