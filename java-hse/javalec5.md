Когда мы инстанцируем дженерик в реальности точки входа и выхода кастуются к тому типу, который мы указали в качестве дженерик-парамента.

Что такое точки входа и выхода? Точки входа - методоты, которые в сигнатуре используют дженерик-тип (кастуют его). Методы, которые возвращают дженерик-тип, - точки выхода.

Точки выхода в wildcard кастуются к наиболее общему типу - Object. Точки входа - NullType. 

```java
void addAll(Object[] a, Collection<?> c) {
    for (int i = 0; i < a.length(); i++) {
        c.add(a[i]); // попытается Object прикастовать к nullType => будет ошибка, так как точка входа.
    }
}
```

В массиве должны быть под классы того, что в коллекции. Только так можно как-то организовать код. До этого мы накладывали ограничение только на один объект, а теперь их два и нужно связть между собой. Это же проблема 3.

```java
addAll(new String[10], new ArrayList<Object>); // чтобы работало
addAll(new Object[10], new ArrayList<String>); // не позволить компилироваться
```

В java есть дженерик-методы.

```java
<T> void addAll(T[] a, Collection<T> c) { // пишем метод и говорим, что он будет параметризовать типом T
    for (int i = 0; i < a.length(); i++) {
        c.add(a[i]);
    }
}
```

С одинаковыми T все ОК, а что если String и Object будет передан на вход. Какой будет `T`?

```java
addAll(new String[10], new ArrayList<Object>());
```

Ответ будет T = Object. Так как дженерики не совместимы по присваиванию с разными дженерик типами, поэтому чтобы код компилировался ответ будет Object. И к тому же на String можно смотреть как на Object.

Соответственно это работать не будет:
```java
addAll(new Object[10], new ArrayList<String>());
```

Есть 4 проблема.
```java
<T> void addAll(Collection<T> c, Collection<T> c2) {
    for (Iterator<T> i = c.iterator(); i.hasNext(); ) {
        T o = i.next();
        c2.add(o);
    }
}
```

Код отлично работает, когда на вход идет одинаковый дженерик тип. Если мы хотим добавить ArrayList Integer в ArrayList Object, что в принципе окей, код не скомпилируется. Типа T должен быть либо Integer, либо Object. Какая должна быть зависимость? Тип левой коллекции должен быть меньше либо равен типу правой коллекции.

Давайте введем метод с двуми дженерик-парамерами. (bounded type argument)

```java
<T, S extends T> void addAll(Collection<S> c, Collection<T> c2) {
    for (Iterator<S> i = c.iterator(); i.hasIterator(); ) {
        S o = i.next();
        c2.add(o);
    }
}
```

Как все происходит: левый аргумен Integer, правый тоже, между ними выполняются требования и все ок.

Второй вариант решить это же проблему это wildcard. Для wildcard можно писать ограничение не только в виде класса, но и в виде дженерик-типа.

```java
<T> void addAll(Collection<? extends T> c, Collection<T> c2) {
    for (Iterator<? extends T> i = c.iterator(); i.hasNext(); ) {
        T o = i.next();
        c2.add(o);
    }
}
```

Со стороны компилятора есть ли различия? Что лучше писать? В первом случае мы заставляем компилятор вывести два типа, ему нужно решить это и проверить функциональную зависимость. А во втором случае у него нет такой проблемы, ему нужно лишь проверить тип который подставляется в эту позицию он подходит, что написано в ? extends T. Поэтому всегда для производительности стоит выбирать вариант с wildcard, если нам не нужно другого???

В первом случае у нас коллекция типа S, итератор типа S и мы также достаем S. Возможно на м это нужно, а возможно нет. В чём разница между двумя вариантами? Во втором случае у нас есть ? extends T, и итератор такого же типа, нам действительно тут все равно, так как мы из первой коллеции дастанем тип T и туда же его засунем.

Если нам нужно явно использовать тот тип, который в коллеции то вариант с вопросиком мы не можем себе позволить.

Мы говорили про стирание типа, когда компилировали дженерик-класс. Что происходит в методе? Внутри метода все будет стерто до Object: стираем аккуратно. Сначала сотрем тип S до T, проверим, что код всё ещё компилируется. А потом тип T сотрем до object.

Соответветственно в варианте с wildcard стирание происходит проще.

В джава нет перегрузки операторв, но мы бы хотели сравнивать. Есть метод equals, если мы хотим сравнивать на больше/меньше, то нужно как-это симулировать этот процесс. Для этого есть несколько вещей: Comparator, Comparable.

У нас есть класс А, который реализует интерфейс Comparable от "яблок". В этом интерфейсе есть интересный метод comapreTo. Так как мы параметризовали его яблоками, то метод будет принимать яблоки. Он возвращает int. Обычно яблок и крокодилов не сравнивают, поэтому чаще всего будет написано Comparable<A> (для сравнения самих себя).

```java
class A implements Comparable<A> {

}
```

Можем написать метод max таким образом:
```java
<T extends Comparable<T>> T max(Collection<T> c) {

}

..

List<Integer> li; Integer i = max(li); // пример использования, который сработает
```

Но тут пришел упоротый-программист, который написал класс Test, сравнимый с Object (implements Comparable<Object>). Элементы типа тест могут сравниваться с кем угодно. 

```java
List<Test> tl; Test t = max(tl); // как бы все ок, элементы могут сравниваться между собой, так как Object может быть сравним с кем угодно.

// но код не скомпилируется. (дженерики не совместимы по присваиванию)
```

Если у нас comparable от какого-то над типа, то все хорошо. И это можно написать (upper bounded wildcard)

```java
<T extends Comparable<? super T>> T max(Collection<T>) {
    ...
}
```

TODO: где можно использовать super, а где нет?

Как можно написать по-другому? На тип T можно давать только одно ограничение. Когда мы указываем дженерик-тип, мы можем использовать только слово extends, слово super там запрещено. TODO: как написать то?

```java
<T extends Comparable<S>> T max(Collection<T>) {
    ...
} // подумать как написать!
```

Прием имени грязного гарри, а именно wildcard capture. Не всегда мы можем использовать wildcard. Когда у нас есть List<?> при попытке взять из него тип, мы получим Object, а в этот момент он принимает NullType => и все, проблема.

```java
void swap(List<?>, int i, int j) {
    ...
}
```

Можно было бы исправить дженерик-типом, но нем БЛИН не дали нормальный вариант, поэтому будем делать грязную магию.

```java
void swap(List<?> list, int i, int j) {
    swapImpl(list, i, j); // у компилятора нет данных для вывода типа, поэтому он подставит Object
}

<T> void swapImpl(List<T> list, int i, int j) {
    T temp = list.get(i);
    list.set(i, list.get(j));
    list.set(j, temp);
}
```
TODO: отличие wildcard от дженериков: про кастование и точки входа и выхода.
00:40:00

В мире Java требуют писать выразительный код, так чтобы он работал для большого количества типов, которые может придумать пользователь.

Например мы хотим написать левую свертку:
`.. foldl(List<..>, Function<.., ..>, .. init)` <- пять типов (дженериков), которых в плохом раскладе будет 5, может меньше, если они между собой связаны. `E foldl(List<A>, Function<B, C>, D init)`, что же делать

        B       E
      / | \     |
     A  C  D    C 

A extends B
C extends B
D extends B => D = B
E = C, но почему? TODO: не понял 00:55:00

TODO: взять все примеры, грязный прием

тут будет пропуск по дженерикам, начну с коллекций

глянуть про сравнение: canEqual (перенрузка canEqual) 