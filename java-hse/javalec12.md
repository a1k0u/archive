В Java есть два пакета, где есть штуки для многопоточного программирования: java.lang, java.util.concurrent (типа надстройка). Что нам ещё нужно, что плохого в java.lang?

1. Synchronized нельзя прервать, нет возможности посомтреть детали блокировки, взять блокировку в течение какого-то времени.
2. Нет возможности взять блокировку в одной части кода и отпустить в другой.
3. ...

В java.util.concurrent есть разные паттерны многопоточного программирования: разные блокировки, атомарные переменные, примитивы синхронизации.

Только один поток может владеть блокировкой, операции: lock, unlock, tryLock(time?)

Интерфейс Lock: lock, lockInterruptibly - блокировка, которую можно прервать (interrupt), unlock, newCondition (создать условие).

Интерфецйс Condition
- await(time?) - ждать условия
- awaitUntil(deadline) - ждать условия до времени
- awaitUninterruptibly (wait - бросает interruptedException) - ждать условие (не бромает исключение)
- signal() - подать сигнал
- signalAll() - подать сигнал всем
! По одному lock можно делать много Condition
! Нужно владеть родительской блокировкой

```java
void set(Object data) throws InterruptedException {
    lock.lock();
    try {
        while (data != null)
            notFull.await();
        this.data = data;
        notEmpty.signal();
    } finally {
        lock.unlock(); // synchronized был устроен,
        // что если выйти из секции, то блокировка снимается
        // с lock это не так. это типичная схема работы с lock 
    }
}
```

Есть несколько реализаций Lock, но в основном все польщзуются ReentrantLock - можно несколько раз его брать (?)

Блокировки, которые есть в java.lang - не честные (ближе всех оказался). .isFair() (?) (при создании ReentrantLock можно указать его честность), .isLocked(), getWaitingThreads(cobdition) / getWaitQueueLength(condition) - потоки, ждущие условие, getQueuedThreads() / getQueueLength() / hasQueuedThred(thread) / hasQueuedThreads() - потоки, ждущие блокировку.

Одновременно писать нельзя; нельзя читать, когда кто-то пишет.

Интерфейс ReadWriteLock (?), реализация - ReentrantReadWriteLock
Методы:
-  readLock() - блокировка для читалелей
-  writeLock() - блокировка для писателей

Интерфейс Executor
- execute(Runnable) - выполнить задание
Возможные варианты выполнения
- в том же потоке
- во вновь создаваемом потоке
- пул потоков
- наращиваемый пул потоков (если потока нет, то создается новый, иначе берется свободный)

Интерфейс `Callable<V>` - функция -> в ExecutorService
- V call() - подсчитать функцию

Интерфейс `Future<V>` - результат <- из ExecutorService 
- get(timeout?) - получить результат (без параметра блокируется)
- isDone() - окончено ли выполнение
- cancel(mayInterrupWhenRunning) - прервать выполнение
- isCancelled() - прервано ли выполнение

Интерфейс ExecutorService
- submit(Runnable) - выполнить задание
- `Future<V> submit(Callble<V>)` - выполнить фукнцию
- List<Future> invokeAll(List <Callable>) - выполнить все функции
- V invokeAny(List <Callable<? extends V>>) - успешно выполнить функцию (есть бд и к ней можно достучаться с нескольких апишников, получаем первый, который получил ответ по пингу).

Future<Void> - хотим например узнать, завершилось ли, потому что по Runnable без доп. кода не сделать так + мы можем отменить задачу у Future.

ExecutorService - сложная вещь. Содердит внутри себя один пользовательский поток. Чтобы нафигачить туда задач и джава дождалась выполнения задач.
- shutdown() (?) - прекратить прием заданий. Заканчивает выполнение оставшихся задач, а после завершает поток.
- List<Runnable> shitdownNow() - прекратить выполнение, вернет оставшиеся задачи из очереди
- isShutdowb() - прекращен ли прием
- isTerminated() - окончены ли все задания
- awaitTermination(timeout) - ожидание завершения

Откуда брать ExecutorService? В джава есть две группы людей: создавать все через конструкторы, создавать через статические методы (в том числе большая часть многопоточки написана такими людми).

Executors.newCachedThreadPoll() - наращиваемый тред пулл
Executors.FixedThreadPool(n) - 
Executors.newSingleThreadExecutor() - тред-пул на один поток, у нас четко последовательные задачи, не нужны блокировки, мы работаем заметно быстрее - например отправка по сети (?)

TimeoutException - timeout закончился

Можно свои бассейны потокв делать ThreadpoolExecutor

Отложенное исполнение. Интерфейс ScheduledExecutorService (schedule, sheduleAtFixedRate, scheduleWithFixedDelay).

Атомарно - нет промежуточного состояния

Неатомарные операции: инкримент, декремент
getAndSet (атомарно) (чтение и запись, то же бы хотелось атомарно..)

Условная запись
comapreAndSet(old, new) - атомарная операция
- Если текущее значение равно old
- Установить значение в new

```java
do {
    old = v.get();
    new = process(old); 
} while(v.compareAndSet(old, new));
// дешевле несколько раз покрутиться в цикле, а
// не брать блокировку, чтобы установить значение
``` 

С помощью CAS можно явно делать lock
```java
while (!v.compareAndSet(0, 1)); // удалось ли выполнить set

// Действия с ресурсом

// Освобождение ресурса
v.set(0);


// из недостатков - активное ожидание, но если
// ожидание недолгое (маленькая критическая
// секция), то это выгоднее, чем выгружаться
```

Неблокирующий счетчик

Немного ещё про атомарные операции в Java

Зачем нужен AtomicReference, если присваиваение ссылки и чтение - атомарно? Каст например можно сделать.

Смотрим картинку, на которой каждый поток инкрементирует в конкурентном режиме (одна пременная) переменную. В идеальном мире, пока количество потоков меньше количества ядер, то горизонтальная линия по времени (Oy - время, Ox - кол-во ядер). После превышения линия пойдет вверх (линейно)

fairLock - работает в нашем случае бесконечно долго, так как мы постоянно выгружаемся.

4.fairLock очень плох в маленьких критических секциях!

3.jit оптимизирует synchronized для int, Integer (method or this) 

2.lock работает быстрее synchronized. Так как внутри lock есть CAS (цикл, маленькая притическая секция), который пытается сделать это без блокировки.

1. atomic

Но на больших критических секция lock проигрывает synchronized.

Под кодом многопоточности - лежит бесконечно много нативного кода.
synchronized - обращение к системным мьютексам
atomic - системные атомарные операции
CAS - сис колл

нативные инструменты - лучше всего!

