# Деревья, структуры данных

#### 1\. Splay. Три вида поворотов. Операция Splay, Add.

**Splay-дерево** - самобалансирующееся BST дерево, не хранящее в вершине
никакой дополнительной информации. В худшем случае глубина дерева
может быть линейна, но амортизационное время всех операций получится
за `O(log n)`.

**Splay** - совершает повороты, то есть чередует различные виды поворотов.

- Zig.
  
<div data-align="center">

<img src="img/graph(11).svg">

</div>

Если `p` - корень дерева с сыном `x`, то совершаем один поворот вокруг
ребра `(x, p)` делая `x` корнем дерева.

  - Zig-zig.

<!-- end list -->

``` plaintext
      z             x
     / \           / \
    y   D         A   y
   / \      <->      / \                (A < x < B < y < C < z < D)
  x   C             B   z
 / \                   / \
A   B                 C   D
```

Если `p` - не корень, а `x` и `p` оба левые или оба праве дети, то
делаем поворот ребра `(p, g)`, где `g` отец `p`, а затем поворот
`(x, p)`.

  - Zig-zag.

<!-- end list -->

``` plaintext
       z                x                y
      / \              / \              / \
     y   D            /   \            A   z       (A < y < B < x < z < D)
    / \         ->   y     z    <-        / \
   A   x            / \   / \            x   D
      / \          A   B C   D          / \
     B   C                             B   C
```

Если `p` - не корень дерева и `x` левый ребенок, а `p` - правый ребенок
`g`, или наоборот, то делаем поворот вокруг ребра `(x, p)`, а затем
поворот нового ребра `(x, g)`, где `g` - бывший родитель `p`.

**Add** - запускам `splay(tree, x)`, если `x` уже был в дереве, то он
становится корнем.

Иначе, если текущий корень меньше `x`, то подвесим его и его левое
поддерево, как левое поддерево для `x`, а правое поддерево
текущего корня, найденного `splay`, как правое поддерево.
Аналогично, то есть наоборот, для случая, когда текущий корень
больше `x`.

#### 2\. Splay. Формулировка главной теоремы о времени работы.

Оценим амортизационное время операции splay, поднявшей `v` в `u`:

``` angular2html
\forall v, u \ a_{v \rightarrow u} \leq 3(R_u - R_v) + 1 = 3 \log{\frac{size_u}{size_v}} + 1
```

`R_k = \log{size_k}`, где `size_k` - размер поддерева.

#### 3\. Rope. Корневая. Через Split/Merge.

…

#### 4\. LCA-Offline.

…

#### 5\. Heavy-Light Decomposition. Определение, построение за `O(n)`.

# Паросочетания

#### 9\. Определение и сложность задач в двудольном и произвольном графе: паросочетание, поиск вершинного покрытия, независимого множества, совершенного паросочетания.

  - **Паросочетание** - множество попарно несмежных ребер.
    <div data-align="center" style="margin: 0; padding: 0;">
    <img style="width: 450px;" src="img/graph2.svg">
    </div>
  - **Вершинное покрытие** - множество таких вершин C, что для любого
    ребра один из концов лежит в C.
    <div data-align="center" style="margin: 0; padding: 0;">
    <img style="width: 600px;" src="img/graph3.svg">
    </div>
  - **Независимое множество** - попарно несмежные вершины.
    <div data-align="center" style="margin: 0; padding: 0;">
    <img style="width: 350px;"  src="img/graph4.svg">
    </div>
  - **Совершенное паросочетание** - паросочетание, покрывающее все
    вершины графа.
    <div data-align="center" style="margin: 0; padding: 0;">
    <img style="width: 450px;"  src="img/graph5.svg">
    </div>

> В двудольном графе совершенное паросочетание - паросочетание,
> покрывающее все вершины меньшей доли.

В произвольном графе задачи: вершинного покрытия, независимого множества
- **NP-трудны**.

Паросочетание в двудольном графе ищется за `O(|M| E)`. В произвольном за
`O(V^3)` - алгоритмом сжатия “соцветий” (*видим нечётный цикл - сожмём
его, найдем паросочетание в новом цикле, разожмём цикл, перестроим
паросочетание*), используемом в реализации Габова.

#### 10\. Лемма о дополняющем пути.

**Чередующийся путь** - путь, в котором идет ребро из паросочетания (не
из паросочетания), а затем ребро не из паросочетания (из
паросочетания).

**ДЧП** (*дополняющий чередующийся путь*) - путь начинающийся и
заканчивающийся в свободной вершине.

<div data-align="center" style="margin: 0; padding: 0;">

<img style="width: 450px;"  src="img/graph7.svg">

</div>

> Красные ребра - ребра из паросочетания, а зеленые - нет. Их
> чередование - ДЧП.

**Свободная вершина** - вершина, не принадлежащая паросочетанию.

**Лемма**. Паросочетание `M` максимально \<=\> не существует ДЧП.

(**=\>**) Предположим, что паросочетание `M` - максимально, и существует
дополняющий путь `P`. Пройдемся по нему: все ребра не из паросочетания
добавятся в паросочетание, а другие удалятся из него. То есть мы
получаем паросочетание `M'` большее `M`, противоречие.

(**\<=**) Пусть есть два паросочетания `M`, `M'` такие, что `|M'| >
|M|`, тогда существует ДЧП относительно `M`. Рассмотрим подграф `H = M
\xor M'`. Граф, в котором будут только ребра, принадлежащие только
одному из паросочетаний. В таком графе степень каждой вершины не
больше двух, так как каждая вершина максимум инцидентна ребру из `M` и
`M'`. В таком графе каждая компонента связности - цикл или путь, в
которых чередуются ребра из M и M’. Так как `|M'| > |M|`, то есть
компонента связности, в которой ребер из `M'` будет больше. Это может
быть только путь, у которого оба ребра принадлежат `M'`. Относительно
`M` этот путь есть ДЧП.

#### 11\. dfs для дополняющего пути, простейший алгоритм за O(V(V + E)).

Пусть `G` - двудольный граф, а `P` паросочетание в нем. Построим граф
`G'(G, P)`, в котором вершины такие же, как в `G`. Ребра: из первой доли
во вторую пустим все рёбра `G`, а из второй в первую ребра из
паросочетания `P`.

Получается, что поиск ДЧП - это поиск пути из свободной в свободную
вершину в графе `G'`.

``` javascript
...

bool dfs(int v) {
    used[v] = true;
    for (int to : graph[v])
        if (pair[to] == -1) or (!used[pair[to]] && dfs(pair[to]))
            pair[to] = v
            return true;
    return false;
}

...

for (int i = 1..n) {
    used[..] = 0;
    dfs(i);
}

...
```

#### 12\. Алгоритм поиска VC и IS за O(E).

Ориентируем ребра паросочетания, чтобы они шли из правой доли в левую,
ребра не из паросочетания — так, чтобы они шли из левой доли в правую.
В графе `G'` запустим `dfs` из свободных вершин первой доли, где
обозначим `A` - первая доля, `B` - вторая. Все посещенные `dfs`
вершины обозначим `A^+`, `B^+`, а непосещённые `A^-`, `B^-`.

`X = A^- \cup B^+` - минимальное вершинное покрытие.

`Y = A^+ \cup B^-` - максимальное независимое множество. Из `A^+` в
`B^-` нет ребер, иначе мы смогли пройти по ним.

<div data-align="center" style="margin: 0; padding: 0;">

<img style="width: 300px;"  src="img/graph8.svg">

</div>

#### 13\. Разбиение вершин орграфа на циклы. Разбиение вершин ацикличного орграфа на минимальное число путей.

**Дан ацикличный орграф (DAG). Разбить все его вершины на минимальное
число путей.**

Возьмём двудольный граф по 𝑛 вершин в каждой доли. Проведём ребро 𝑖 → 𝑗
исходного графа из 𝑖-й вершины первой доли в 𝑗-ую вершину второй доли.
Такая операция называется «раздвоение орграфа». В раздвоенном графе
возьмём рёбра максимального паросочетания, нарисуем их в исходном,
получили разбиение на минимальное число путей.

#### 14\. Stable matching (marriage problem). Постановка задачи. Решение. Пример про ЕГЭ.

Сформулируем задачу на языке мальчиков/девочек. Есть `n` мальчиков, у
каждого из них есть список девочек `bs[a]`, которые ему нравятся в
порядке наиболее приоритетных к менее. Есть `m` девочек, у которых
есть такой же список, относящийся к мальчикам, `as[b]`. `!` Мальчики
и девочки хотят образовать пары.

Никто не готов образовывать пару с тем, кто вообще отсутствует в его
списке. И для мальчиков, и для девочек наименее приоритетный вариант
- остаться без пары.

> Обозначим `p_a` - пара для мальчика `a` или `-1`, `q_b` - пара для
> девочки `q` или `-1`.

Паросочетание называется `не стабильным`, есть существует мальчик `a` и
девочка `b`: мальчику `a` нравится `b` больше чем `p_a` и девочке `b`
нравится `a` больше чем `q_b`.

Иначе паросочетание называется `стабильным`.

**Решение:** Изначально проинициализируем `p_a = bs[a].best`, далее,
пока есть `i != j` и девочка `b = p_i = p_j != -1`. Девочка `b`
откажет тому из них, кто ей меньше нравится. Пусть она отказала
мальчику `i`, тогда делаем `bs[i].remove_best()`, `p_i =
bs[i].best`.

**Пример:** Студенты хотят поступить в ВУЗы. У каждого ВУЗа есть
ограниченное количество мест и могут быть разные приоритеты,
кого хотят брать. Строим двудольный граф, каждый студент указывает
список ВУЗов в приоритетности. Каждое место-в-вузе получает список
студентов в порядке приоритета данного ВУЗа. Ищем стабильное
паросочетание, получаем решение, оптимальное для студентов.

# Потоки

#### 15\. Def: поток, разрез, величина потока, величина разреза, сотаточная сеть, циркуляция, прямые и обратные ребра, декомпозиция потока.

**Поток в орграфе** из s в t - сопоставленные ребрам числа `f_e \in
\mathbb{R}`.

> (e E : 0 f\_e c\_e)  (v s, t: *{e in(v)} f\_e = *{e out(v)} f\_e).

**Разрез** - дизъюнктное разбиение вершин (S, t): v = S T. s S, t T.

**Величина потока** `|f|` = `\sum_{e \in out(s)} f_e` - `\sum_{e \in
in(s)} f_e`

**Величина разреза** - называется сумма пропускных способностей таких
рёбер ( i , j )
\({\displaystyle (i,j)} (i, j), что i ∈ S , j ∈ T {\displaystyle i\in S,j\in T} i\in S,j\in T\).

\[1 + 1\]

<img src="https://latex.codecogs.com/svg.latex?\Large&space;x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}" title="\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}" />

**Циркуляция** - поток величины нуль.

**Прямые и обратные ребра** - для каждого ребра сети `G` с пропускной
способностью `c_e` создадим обратное ребро `e'` пропускной
способностью 0. При этом по определению `f_e'` = `-f_e`.

**Декомпозиция потока f** - представление `f` в виде суммы элементарных
потоков (путей) и циркуляции.

**Остаточная сеть потока f** - `G_f`, граф с пропускными способностями
c\_e - f\_e.

#### 16\. Алгоритм Форда-Фалкерсона. Время работы. Без доказательства.

**Теорема**. Форда-Фалкерсона. 1. `|f|` = max \<=\> нет дополняющего
пути. 2. `max |f|` = `min C(S, T)` (максимальный поток равен
минимальному разрезу)

Из теоремы следует простейший алгоритм поиска максимального потока: пока
есть дополняющий путь p, найдем его, толкнем по нему `x = min (c_e -
f_e)`, где `e \in p`, единиц потока.

Время работы алгоритма `O(|f| E)`.

``` javascript
int dfs(int v, int go) {
    used[v] = 1;
    if (v == t) return go;

    for (int edge : vertexes[v]) {
        Edge& e = edges[edge];
        if (e.f < e.c && !used[e.b]) {
            int push = dfs(e.b, min(e.c - e.f, go));
            if (push) {
                e.f += push;
                edges[e.rev].f -= push;
                return push;
            }
        }
    }
    return 0;
}
```

#### 17\. Поиск min разреза по max току за `O(E)`.

Пусть нет дополняющего пути =\> `dfs` из `s` по ненасыщенным ребрам не
посетит `t`. Множество посещенных вершин обозначим `S`, обозначим `T =
V \ S`. Из `S` в `T` ведут только `e`: `f_e = c_e`. Это же есть алгоритм
min разреза по max потоку за `O(E)`.

#### 18\. Декомпозиция потока на пути за `O(E^2)`. Циркуляция.

Пока `|f| > 0` найдем путь `p` из `s` в `t` по ребрам `e`: `f_e > 0`. По
всем ребрам пути уменьшим поток на `min f_e`, `e \in p`.

`O(E^2)` после нахождения пути и уменьшения потока, как минимум у одного
ребра `f_e` обнулится =\> не более `E` поисков пути.

#### 19\. Решение задачи про `k` непересекающихся по ребрам/вершинам путей.

**Поиск реберно непересекающихся путей** *Орграф:* каждому
ориентированному ребру зададим пропускную способность `1`,
найдем максимальный поток. `|f|` - количество реберно непересекающихся
путей.

*Неорграф:* приводим к орграфу, делаем то же самое.

**Поиск вершинно непересекающихся путей** *Орграф:* раздваиваем вершину,
посередине ребро с пропускной способностью 1, входящие ребра в первую
половину, исходящие из второй.

*Неорграф:* приводим к орграфу, делаем то же самое.

#### 20\. Поиск паросочетания через поток за `O(VE)`.

Чтобы с помощью поток искать максимальное паросочетание добавим исток и
сток. Из стока направим ребра в первую долю с пропускными способностями
- `1`. Аналогично из второй доли в сток. Если изначально двудольный граф
был неориентированным, то направим ребра из первой во вторую долю.
Пропускная способность этих ребер может быть любой, так как из
вершины не второй доли в сток не может пойти поток больше `1`.
Запустим алгоритм Форда-Фалкерсона за `O(|f| * E) = O(|M| * E) <=
O(VE)`.

#### 21\. Глобальный разрез: определение, базовое решение на `O(V * flow)`.

**Глобальный разрез** равен минимуму среди разрезов минимальной
стоимости по всевозможным парам исток-сток.

Простейшее решение: переберем `s`, `t` и найдем разрез между ними за
`O(V * flow)`.

#### 22\. Транспортная задача. Формулировка. Решение.

В городе есть дороги, заводы и магазины. Дороги образуют орграф, у
каждой дороги есть длина `w_i` и пропускная способность `u_i`.
Каждый день `i`-й завод выпускает `A_i` единиц товара, а `j`-й
магазин продает `B_j` единиц. Нужно построить план доставки, чтобы
`\sum f_i \cdot w_i` была минимальна.

**Решение:**

…

#### 23\. Задачи mincost k-flow, mincost max flow, mincost circulation. Сведения друг к другу.

…

# Строки

#### 27\. КМП для поиска подстроки.

`\pi_0 (s)` - длина max собственного префикса `s`, совпадающего с
суффиксом `s`.

**Префикс-функция** строки `s` - массив `\pi (s)`: `\pi (s) [i]` =
`\pi_0 (s[0:i))`
