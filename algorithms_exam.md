# Деревья, структуры данных

#### 1\. Splay. Три вида поворотов. Операция Splay, Add.

Splay-дерево - самобалансирующееся BST дерево, не хранящее в вершине
никакой дополнительной информации. В худшем случае глубина дерева
может быть линейна, но амортизационное время всех операций получится
за `O(log n)`.

**Splay** - совершает повороты, но чередует различные виды поворотов.

  - Zig.

<!-- end list -->

``` plaintext
    y             x
   / \           / \   
  x   C   <->   A   y
 / \               / \
A   B             B   C
```

Если `p` - корень дерева с сыном `x`, то совершаем один поворот вокруг
ребра `(x, p)` делая `x` корнем дерева.

  - Zig-zig.

<!-- end list -->

``` plaintext
      z             x
     / \           / \
    y   D         A   y
   / \      <->      / \                (A < x < B < y < C < z < D)
  x   C             B   z
 / \                   / \
A   B                 C   D
```

Если `p` - не корень, а `x` и `p` оба левые или оба праве дети, то
делаем поворот ребра `(p, g)`, где `g` отец `p`, а затем поворот
`(x, p)`.

  - Zig-zag.

<!-- end list -->

``` plaintext
       z                x                y
      / \              / \              / \
     y   D            /   \            A   z       (A < y < B < x < z < D)
    / \         ->   y     z    <-        / \
   A   x            / \   / \            x   D
      / \          A   B C   D          / \
     B   C                             B   C
```

Если `p` - не корень дерева и `x` левый ребенок, а `p` - правый ребенок
`g`, или наоборот, то делаем поворот вокруг ребра `(x, p)`, а затем
поворот нового ребра `(x, g)`, где `g` - бывший родитель `p`.

**Add** - запускам `splay(tree, x)`, если `x` уже был в дереве, то он
становится корнем.

Иначе, если текущий корень меньше `x`, то подвесим его и его левое
поддерево, как левое поддерево для `x`, а правое поддерево
текущего корня, найденного `splay`, как правое поддерево.
Аналогично, то есть наоборот, для случая, когда текущий корень
больше `x`.

#### 2\. Splay. Формулировка главной теоремы о времени работы.

Оценим амортизационное время операции splay, поднявшей `v` в `u`:

``` angular2html
\forall v, u \ a_{v \rightarrow u} \leq 3(R_u - R_v) + 1 = 3 \log{\frac{size_u}{size_v}} + 1
```

`R_k = \log{size_k}`, где `size_k` - размер поддерева.

#### 3\. Rope. Корневая. Через Split/Merge.

…

#### 4\. LCA-Offline.

…

#### 5\. Heavy-Light Decomposition. Определение, построение за `O(n)`.

# Паросочетания

#### 9\. Определение и сложность задач в двудольном и произвольном графе: паросочетание, поиск вершинного покрытия, независимого множества, совершенного паросочетания.

  - **Паросочетание** - множество попарно несмежных ребер.
    <div data-align="center" style="margin: 0; padding: 0;">
    <img style="width: 450px;" src="img/graph2.svg">
    </div>
  - **Вершинное покрытие** - множество таких вершин C, что для любого
    ребра один из концов лежит в C.
    <div data-align="center" style="margin: 0; padding: 0;">
    <img style="width: 600px;" src="img/graph3.svg">
    </div>
  - **Независимое множество** - попарно несмежные вершины.
    <div data-align="center" style="margin: 0; padding: 0;">
    <img style="width: 350px;"  src="img/graph4.svg">
    </div>
  - **Совершенное паросочетание** - паросочетание, покрывающее все
    вершины графа.
    <div data-align="center" style="margin: 0; padding: 0;">
    <img style="width: 450px;"  src="img/graph5.svg">
    </div>

> В двудольном графе совершенное паросочетание - паросочетание,
> покрывающее все вершины меньшей доли.

В произвольном графе задачи: вершинного покрытия, независимого множества
- **NP-трудны**.

Паросочетание в двудольном графе ищется за `O(|M| E)`. В произвольном за
`O(V^3)` - алгоритмом сжатия “соцветий” (*видим нечётный цикл - сожмём
его, найдем паросочетание в новом цикле, разожмём цикл, перестроим
паросочетание*), используемом в реализации Габова.

#### 10\. Лемма о дополняющем пути.

**Чередующийся путь** - путь, в котором идет ребро из паросочетания (не
из паросочетания), а затем ребро не из паросочетания (из
паросочетания).

**ДЧП** (*дополняющий чередующийся путь*) - путь начинающийся и
заканчивающийся в свободной вершине.

<div data-align="center" style="margin: 0; padding: 0;">

<img style="width: 450px;"  src="img/graph7.svg">

</div>

> Красные ребра - ребра из паросочетания, а зеленые - нет. Их
> чередование - ДЧП.

**Свободная вершина** - вершина, не принадлежащая паросочетанию.

**Лемма**. Паросочетание `M` максимально \<=\> не существует ДЧП.

(**=\>**) Предположим, что паросочетание `M` - максимально, и существует
дополняющий путь `P`. Пройдемся по нему: все ребра не из паросочетания
добавятся в паросочетание, а другие удалятся из него. То есть мы
получаем паросочетание `M'` большее `M`, противоречие.

(**\<=**) Пусть есть два паросочетания `M`, `M'` такие, что `|M'| >
|M|`, тогда существует ДЧП относительно `M`. Рассмотрим подграф `H = M
\xor M'`. Граф, в котором будут только ребра, принадлежащие только
одному из паросочетаний. В таком графе степень каждой вершины не
больше двух, так как каждая вершина максимум инцидентна ребру из `M` и
`M'`. В таком графе каждая компонента связности - цикл или путь, в
которых чередуются ребра из M и M’. Так как `|M'| > |M|`, то есть
компонента связности, в которой ребер из `M'` будет больше. Это может
быть только путь, у которого оба ребра принадлежат `M'`. Относительно
`M` этот путь есть ДЧП.

#### 11\. dfs для дополняющего пути, простейший алгоритм за O(V(V + E)).

Пусть `G` - двудольный граф, а `P` паросочетание в нем. Построим граф
`G'(G, P)`, в котором вершины такие же, как в `G`. Ребра: из первой доли
во вторую пустим все рёбра `G`, а из второй в первую ребра из
паросочетания `P`.

Получается, что поиск ДЧП - это поиск пути из свободной в свободную
вершину в графе `G'`.

``` javascript
...

bool dfs(int v) {
    used[v] = true;
    for (int to : graph[v])
        if (pair[to] == -1) or (!used[pair[to]] && dfs(pair[to]))
            pair[to] = v
            return true;
    return false;
}

...

for (int i = 1..n) {
    used[..] = 0;
    dfs(i);
}

...
```

#### 12\. Алгоритм поиска VC и IS за O(E).

Ориентируем ребра паросочетания, чтобы они шли из правой доли в левую,
ребра не из паросочетания — так, чтобы они шли из левой доли в правую.
В графе `G'` запустим `dfs` из свободных вершин первой доли, где
обозначим `A` - первая доля, `B` - вторая. Все посещенные `dfs`
вершины обозначим `A^+`, `B^+`, а непосещённые `A^-`, `B^-`.

`X = A^- \cup B^+` - минимальное вершинное покрытие.

`Y = A^+ \cup B^-` - максимальное независимое множество. Из `A^+` в
`B^-` нет ребер, иначе мы смогли пройти по ним.

<div data-align="center" style="margin: 0; padding: 0;">

<img style="width: 300px;"  src="img/graph8.svg">

</div>

#### 13\. Разбиение вершин орграфа на циклы. Разбиение вершин ацикличного орграфа на минимальное число путей.

**Дан ацикличный орграф (DAG). Разбить все его вершины на минимальное
число путей.**

Возьмём двудольный граф по 𝑛 вершин в каждой доли. Проведём ребро 𝑖 → 𝑗
исходного графа из 𝑖-й вершины первой доли в 𝑗-ую вершину второй доли.
Такая операция называется «раздвоение орграфа». В раздвоенном графе
возьмём рёбра максимального паросочетания, нарисуем их в исходном,
получили разбиение на минимальное число путей.

#### 14\. Stable matching (marriage problem). Постановка задачи. Решение. Пример про ЕГЭ.

Сформулируем задачу на языке мальчиков/девочек. Есть `n` мальчиков, у
каждого из них есть список девочек `bs[a]`, которые ему нравятся в
порядке наиболее приоритетных к менее. Есть `m` девочек, у которых
есть такой же список, относящийся к мальчикам, `as[b]`. `!` Мальчики
и девочки хотят образовать пары.

Никто не готов образовывать пару с тем, кто вообще отсутствует в его
списке. И для мальчиков, и для девочек наименее приоритетный вариант
- остаться без пары.

> Обозначим `p_a` - пара для мальчика `a` или `-1`, `q_b` - пара для
> девочки `q` или `-1`.

Паросочетание называется `не стабильным`, есть существует мальчик `a` и
девочка `b`: мальчику `a` нравится `b` больше чем `p_a` и девочке `b`
нравится `a` больше чем `q_b`.

Иначе паросочетание называется `стабильным`.

**Решение:** Изначально проинициализируем `p_a = bs[a].best`, далее,
пока есть `i != j` и девочка `b = p_i = p_j != -1`. Девочка `b`
откажет тому из них, кто ей меньше нравится. Пусть она отказала
мальчику `i`, тогда делаем `bs[i].remove_best()`, `p_i =
bs[i].best`.

**Пример:** Студенты хотят поступить в ВУЗы. У каждого ВУЗа есть
ограниченное количество мест и могут быть разные приоритеты,
кого хотят брать. Строим двудольный граф, каждый студент указывает
список ВУЗов в приоритетности. Каждое место-в-вузе получает список
студентов в порядке приоритета данного ВУЗа. Ищем стабильное
паросочетание, получаем решение, оптимальное для студентов.

# Потоки

#### 15\. Def: поток, разрез, величина потока, величина разреза, сотаточная сеть, циркуляция, прямые и обратные ребра, декомпозиция потока.

**Поток в орграфе** из s в t - сопоставленные ребрам числа `f_e \in
\mathbb{R}`.

> (e E : 0 f\_e c\_e)  (v s, t: *{e in(v)} f\_e = *{e out(v)} f\_e).

**Разрез** - дизъюнктное разбиение вершин (S, t): v = S T. s S, t T.

**Величина потока** `|f|` = `\sum_{e \in out(s)} f_e` - `\sum_{e \in
in(s)} f_e`

**Величина разреза** - называется сумма пропускных способностей таких
рёбер ( i , j )
\({\displaystyle (i,j)} (i, j), что i ∈ S , j ∈ T {\displaystyle i\in S,j\in T} i\in S,j\in T\).

\[1 + 1\]

<img src="https://latex.codecogs.com/svg.latex?\Large&space;x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}" title="\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}" />

**Циркуляция** - поток величины нуль.

**Прямые и обратные ребра** - для каждого ребра сети `G` с пропускной
способностью `c_e` создадим обратное ребро `e'` пропускной
способностью 0. При этом по определению `f_e'` = `-f_e`.

**Декомпозиция потока f** - представление `f` в виде суммы элементарных
потоков (путей) и циркуляции.

**Остаточная сеть потока f** - `G_f`, граф с пропускными способностями
c\_e - f\_e.

#### 16\. Алгоритм Форда-Фалкерсона. Время работы. Без доказательства.

**Теорема**. Форда-Фалкерсона. 1. `|f|` = max \<=\> нет дополняющего
пути. 2. `max |f|` = `min C(S, T)` (максимальный поток равен
минимальному разрезу)

Из теоремы следует простейший алгоритм поиска максимального потока: пока
есть дополняющий путь p, найдем его, толкнем по нему `x = min (c_e -
f_e)`, где `e \in p`, единиц потока.

Время работы алгоритма `O(|f| E)`.

``` javascript
int dfs(int v, int go) {
    used[v] = 1;
    if (v == t) return go;

    for (int edge : vertexes[v]) {
        Edge& e = edges[edge];
        if (e.f < e.c && !used[e.b]) {
            int push = dfs(e.b, min(e.c - e.f, go));
            if (push) {
                e.f += push;
                edges[e.rev].f -= push;
                return push;
            }
        }
    }
    return 0;
}
```

#### 17\. Поиск min разреза по max току за `O(E)`.

Пусть нет дополняющего пути =\> `dfs` из `s` по ненасыщенным ребрам не
посетит `t`. Множество посещенных вершин обозначим `S`, обозначим `T =
V \ S`. Из `S` в `T` ведут только `e`: `f_e = c_e`. Это же есть алгоритм
min разреза по max потоку за `O(E)`.

#### 18\. Декомпозиция потока на пути за `O(E^2)`. Циркуляция.

Пока `|f| > 0` найдем путь `p` из `s` в `t` по ребрам `e`: `f_e > 0`. По
всем ребрам пути уменьшим поток на `min f_e`, `e \in p`.

`O(E^2)` после нахождения пути и уменьшения потока, как минимум у одного
ребра `f_e` обнулится =\> не более `E` поисков пути.

#### 19\. Решение задачи про `k` непересекающихся по ребрам/вершинам путей.

**Поиск реберно непересекающихся путей** *Орграф:* каждому
ориентированному ребру зададим пропускную способность `1`,
найдем максимальный поток. `|f|` - количество реберно непересекающихся
путей.

*Неорграф:* приводим к орграфу, делаем то же самое.

**Поиск вершинно непересекающихся путей** *Орграф:* раздваиваем вершину,
посередине ребро с пропускной способностью 1, входящие ребра в первую
половину, исходящие из второй.

*Неорграф:* приводим к орграфу, делаем то же самое.

#### 20\. Поиск паросочетания через поток за `O(VE)`.

Чтобы с помощью поток искать максимальное паросочетание добавим исток и
сток. Из стока направим ребра в первую долю с пропускными способностями
- `1`. Аналогично из второй доли в сток. Если изначально двудольный граф
был неориентированным, то направим ребра из первой во вторую долю.
Пропускная способность этих ребер может быть любой, так как из
вершины не второй доли в сток не может пойти поток больше `1`.
Запустим алгоритм Форда-Фалкерсона за `O(|f| * E) = O(|M| * E) <=
O(VE)`.

#### 21\. Глобальный разрез: определение, базовое решение на `O(V * flow)`.

**Глобальный разрез** равен минимуму среди разрезов минимальной
стоимости по всевозможным парам исток-сток.

Простейшее решение: переберем `s`, `t` и найдем разрез между ними за
`O(V * flow)`.

#### 22\. Транспортная задача. Формулировка. Решение.

В городе есть дороги, заводы и магазины. Дороги образуют орграф, у
каждой дороги есть длина `w_i` и пропускная способность `u_i`.
Каждый день `i`-й завод выпускает `A_i` единиц товара, а `j`-й
магазин продает `B_j` единиц. Нужно построить план доставки, чтобы
`\sum f_i \cdot w_i` была минимальна.

**Решение:**

…

#### 23\. Задачи mincost k-flow, mincost max flow, mincost circulation. Сведения друг к другу.

…

# Строки

#### 27\. КМП для поиска подстроки.

`\pi_0 (s)` - длина max собственного префикса `s`, совпадающего с
суффиксом `s`.

**Префикс-функция** строки `s` - массив `\pi (s)`: `\pi (s) [i]` =
`\pi_0 (s[0:i))`

# Flask

### Введение

> **Flask** - микрофреймворк\[1\] для создания сайтов.

Для дальнейшей работы нужно понять принцип взаимодействия между
**клиентом** (браузером) и **сервером** (нашим фреймворком).

Когда пользователь вводит желанный сайт, браузер отправляет запрос на
**DNS-сервер**\[2\], чтобы получить **IP-адрес**\[3\] нашего сайта.
Затем по полученному IP отправляется запрос, который возвращает
ответ в виде какого-то документа.

``` text
User -[url]-> DNS -[ip]-> User -[ip]-> Server -[Document]-> User.
```

Наш фреймворк установлен на сервере, которому веб-сервер\[4\] отдает
запрос на обработку. Между Python-программой и сервером находиться
прослойка в виде **WSGI-приложением** \[*Web Server Gateway
Interface*\], предоставляющим удобный интерфейс для взаимодействия с
сервером.

При поступлении нового запроса активизируется WSGI-приложение,
выполняется определенный обработчик, который называется
“**Представление**”. При нескольких запросах обработчики работают
в многопоточном режиме.

**Установка** микрофреймворка происходит через пакетный менеджер в CLI
командой: `pip install Flask`.

Создадим простое WSGI-приложение, которое по url “/” будет возвращать
заголовок “Some Text”.

``` python
from flask import Flask

app = Flask(__name__)


@app.route("/")
def index():
    return "<h1>Some Text</h1>"


if __name__ == "__main__":
    app.run(debug=True)
```

В Haskell есть механизм вывода типов, поэтому не нужно его указывать,
так как язык самостоятельно выведет его.

``` haskell
ghci> :t True
True :: Bool
```

Символ `::` означает: “имеет тип”.

``` haskell
ghci> :t "Hello, my friend!"
"Hello, my friend!" :: [Char]

ghci> :t (True, 1, "a")
(True, 1, "a") :: (Bool, Int, Char)
```

У функций тоже есть типы, хорошим тоном является указывать их явно.

``` haskell
foo :: [Char] -> [Char]
foo st = [c | c <- st, c `elem` ['A' .. 'Z']]
```

**Встроенные типы в языке Haskell:**

  - **Int** - в зависимости от разрядности системы принимает значения от
    -2^n до 2^n - 1, где n - разрядность.
  - **Integer** - а-ля не имеет ограничений, то есть очень большой. \>
    Int работает более эффективно в сравнении с Integer.
  - **Float** - число с плавающей точкой одинарной точности.
  - **Double** - двойная точность. Для предоставления чисел используется
    вдвое больше битов.
  - **Bool**, **Char** (`литералы в одинарных кавычках`), **()**
    (`кортеж`): теоретически количество типов кортежей бесконечно.

> **a** - типовая переменная, то есть ***a*** может быть любым типом.

``` haskell
ghci> :t head
head :: [a] -> [a] 
```

> Подобные элементы в других языках называют “дженериками”, но только в
> Haskell - это мощный инструмент, так как позволяет нам легко писать
> самые общие функции.

``` haskell
ghci> :t fst
fst :: (a, b) -> a
```

**Класс типов** - интерфейс, определяющий некоторое поведение. Такие
операторы, как (==), являются функциями.

``` haskell
ghci> :t (==)
(==) :: (Eq a) => a -> a -> Bool
```

> Всё, что находится перед символом **=\>**, называется *ограничителем
> класса*. Тип этих двух значений должен быть экземпляром класса *Eq*.

**Класс типа Eq** - предоставляет интерфейс для сравнения двух значений
на равенство.

> Класс типов в Haskell /= классы в ООП ЯП.

  - `Ord -> Ordering = EQ | GT | LT.`
  - `Show -> show` *(вывод)*
  - `Read -> read` *(интерпретатор GHCi вычисляет, определяя тип)*

<!-- end list -->

``` haskell
ghci> read "8" + 3
11
ghci> read "(3, 'a')" :: (Int, Char)
(3, 'a')
ghci> [read "True", False]
[True, False]
```

**Аннотация типа** - явный способ указать, какого типа должно быть
выражение.

  - **Enum** - экземпляры этого типа можно пронумеровать.

<!-- end list -->

``` haskell
ghci> [3 .. 5]
[3, 4, 5]
```

  - **Bounded** - экземпляры класса имеют верхнюю и нижнюю границу.

<!-- end list -->

``` haskell
ghci> minBound :: Int
-2147483648
```

  - **Num** - класс типов для чисел. `(Double, Int, ...)`

<!-- end list -->

``` haskell
ghci> :t (*)
(*) :: (Num a) => a -> a -> a
```

  - **Floating** - числа с плавающей точкой.

  - **Integral** - целые числа.

<!-- end list -->

``` haskell
ghci> fromIntegral (length [1, 2]) + 3.2
5.2
ghci> :t fromIntegral
fromIntegral :: (Num b, Integral a) => a -> b
ghci> :t length
length :: [a] -> Int
```

# 7\. Создание новых типов и классов типов.

Один из способов создать свой собственный тип - `data`.

``` haskell
ghci> data Bool = False | True
ghci> data Shape = Circle Float Float Float | Rec Float Float Float Float
```

Когда мы записываем конструктор значения типа, опционально можем
добавить типы после имени; эти типы определяют, какие значения
будет содержать тип с данным конструктором.

``` haskell
ghci> :t Circle
Circle :: Float -> Float -> Float -> Shape
```

``` haskell
ghci> area :: Shape -> Float
ghci> area (Circle _ _ r) = pi * r ^ 2
ghci> area $ Circle 3 4 10
314.15927
```

Чтобы определить для нашего типа `Shape` экземпляр класса `Show`,
модифицируем его следующим образом.

``` haskell
data Shape = Circle Float Float Float deriving (Show)        
```

``` haskell
ghci> Circle 10 20 30
Cirlce 10.0 20.0 30.0
```

**Конструкторы значений** - это функция.

``` haskell
data Point = Point Float Float deriving (Show)
data Shape = Circle Point Float | Rectangle ... deriving (Show)
```

Подвигаем наши фигуры:

``` haskell
nudge :: Shape -> Float -> Float -> Shape
nudge (Circle (Point x y) r) a b = Circle (Point (x + a) (y + b)) r
```

Создадим тип, отображающий информацию о человеке.

``` haskell
data Person = Person String String Int Float String String deriving (Show)
```

``` haskell
ghci> let guy = Person "Фредди" "Крюгер" 43 184.2 "526–2928" "Эскимо" ghci> guy
Person "Фредди" "Крюгер" 43 184.2 "526–2928" "Эскимо"
```

Но есть синтаксис для более читаемой формы, он же генерирует функции для
извлечения полей.

``` haskell
data Person = Person { firstName :: String 
                     , lastName :: String
                     , age :: Int
                     , height :: Float
                     , phoneNumber :: String
                     , flavor :: String } deriving (Show)
```

``` haskell
ghci> :t flavor
flavor :: Person –> String
ghci> :t firstName
firstName :: Person –> String
```

# Pytest

Названия для файлов (*py*) должны иметь префикс или постфикс **test**.

``` shell
touch test_some.py
```

Аналогично и с функциями.

``` python
def test_equal():
    assert 1 == 1, "Lol"
```

Запуск теста.

``` shell
pytest ./tests/*
```

\-s - вывод.

\-v - полное название.

``` python
@pytest.mark.parametrize(vars ..., [(), ...])
def test_... :
    ...
```

``` python
with pytest.raises(...):
    ...
```

# II. Системное программирование.

## 2\. Системные инструменты.

При использовании стандартной библиотеки сценарии на Python
автоматически становятся *переносимыми*.

Большинство интерфейс для системной разработки находятся: **sys**,
**os**, **glob** (подстановка имён файлов), **socket** (создание сетевых
соединений и взаимодействие между процессами), **threading**,
\*\*\_tread**, **queue** (средства запуска и синхронизации параллельных
потоков), **time**, **timeit\*\* (системное время), **subprocess**,
**multiprocessing** (запуск и управление параллельными процессами),
**signal**, **select**, **shutil**, **tempfile** (решение других
системных задач).

*open* - системные интерфейс (функция).

**sys** - экспортирует компоненты, относящиеся к самому интерпретатору
Python.

**os** - содержит переменные и функции, сопутствующие ОС.

Функция **help** - один из интерфейсов, предоставляемых вместе с PyDoc.

Модуль **string** - определяет некоторые полезные константы.

**bytes** - последовательность коротких целых чисел для представления 8
битовых данных, а **bytesarray** - это изменяемый вариант.

``` python
open("file").read() # считывает файл в строку (память).
```

\_\_ main\_\_ записывается в \_\_ name\_\_ только в том случае, если
выполняется как программа, а не импортированная библиотека.

**sys.platform** - ОС

**sys.maxsize** - максимальное число, поддерживаемое платформой.

**sys.version** - информация об интерпретаторе Python.

**sys.path** - путь поиска модулей для Python.

**\\** - win, **/** - Unix, Python обеспечивает переносимость.

**sys.modules** - словарь импортируемый модулей в сеанс.

**sys.getrefcount(…)** - ссылки на объект.

**sys.builtin\_module\_names** - встроенные модули.

**sys.exc\_info()** - тип последнего исключения, его значение и объект с
трассировочной информацией.

Объект с трассировочной информацией можно обрабатывать с помощью модуля
**traceback**.

traceback - ?

с. 150 \# 👋

This is my own archive to show activity in learning programming. Most of
the time I’m researching new things and I want to share this on GitHub.
There is nothing new here, this code can be written after tutorials,
articles, documentation, books, etc. But I wrote it myself, you can be
sure that I know what I learned :)

Some parts of this code may be lead by comments and some useful URLs.
Please enjoy and explore it\!

### Запросы на выборку, соединение таблиц.

`INNER JOIN` - соединяет две таблицы, порядок не важен, т.к. оператор
симметричен.

``` sql
SELECT 
    ...
FROM
    t1 INNER JOIN t2
    ON contidion
...
```

  - Каждая строка одной таблицы сопоставляется с каждой строкой второй
    таблицы.
  - Для получения “соединенной” таблицы проверяет условие соединения.
  - Если истинно, то добавляет строку.

<!-- end list -->

1.  Фреймворк - программная платформа (набор библиотек), призванная
    облегчить разработку продукта путём предоставления всего
    необходимого инструментария. Микрофреймворк - ограничен по
    функциям, но он легковеснее и, как правило, хорошо защищён.

2.  DNS (Domain Name Server) - специализированный компьютер, который
    хранит IP-адреса сайтов.

3.  IP (Internet Protocol) - уникальный числовой идентификатор
    устройства в компьютерной сети.

4.  Веб-сервер - сервер, принимающий HTTP-запросы от клиентов. \# 2.
    Типы и классы типов.
