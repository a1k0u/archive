В Unix приняло делать одну программу (небольшую), которая делает это очень хорошо.

Механизм канало - выход одной программы, переправляем на вход другой. Но тут необошлось без файловых дескрипторов. 

`man pipe` - читаем про системный вызов, возращает дескрипторов для каналов.

```c
int main() {
    int fd[2];

    if (pipe(fd) < 0) {
        perror("pipe");
        return 1;
    }

    if (!fork()) {
        for (int i = 0; i < 10; ++i) {
            dprintf(fd[1], "line %d\n", i);
        }
        return 0;
    }

    char buf[100] = {0};
    ssize_t size;
    while((size = read(fd[0], buf, sizeof(buf))) > 0) {
        printf("read %ld bytes from the pipe: [%s]\n", size, buf);
    }
}
```

Считываем в родительском процессе мы действительно кусками. Ребенок отработал -  превратился в зомби. А родитель завис на системном вызове read.

Ситуация конца файла настала тогда, когда в канале не осталось ни одного живого дескриптора. То есть (поправочка), когда с одного конца канала перестали отдавать на выход результат, то первый процесс умирает. И с другого конца приходит EOF.

Так как fork все копирует, то в ребенке все погибло, а в родители все осталось. Чтобы починить нашу программу в родителе нужно `close(fd[1])`.

fd[0] - читающий stdin
fd[1] - пишущий  stdout

Мы пока научились связывать каналом родственным процессом.

Мораль: внимательно следить за границами, чтобы процесс завершался.

Если программа, типа `yes`, которая генирирует бесконечный вывод в stdout, прокинуть в канал с head. ТО все прекрасно отработает, вроде как лениво.

`yes | head`

Ядро отслеживает вторую специальную ситуацию (первая связана с не закрытыми дескрипторами), когда не осталось читающий файловых дескрипторов. Если мы пытаемся записать в канал, у которого не осталось читающий файловых дескрипторов, то ядро некоторым магическим образом убивает процесс, который пытается записать.

У каналов есть атомарность на чтение и запись, если будет записано меньше чем `PIPE_BUF`. На линукс - 4096 KiByte.

dup2(имеющийся файловый дескриптор, куда его прицепим), воспользуемся этим для достижения второй ситуации.

dup(fd[], ...)

grep foo | grep bar (строка в которой есть подстроки foo и bar) - не работает, но почему? Так как в grep буфферзирован вывод, то команда выдаст результат, когда будет переполнение. --line-buffred - хак. Выводит сразу, так как есть \n на входе. А записывает передает результат не сразу, так как есть буффер.

- no buffering -> printf("hello") write("hello")
- line         -> заполнение буффера, \n
- full         -> сброс, если буфер полностью заполнен

Для pipe между неродственными процессами есть механизм FIFO (also knows as named pipes). `man 7 pipe`

`mkfifo fifo` - создали именованный pipe

`echo "hello" > fifo` - открыли fifo и ждемс (системный вызов заблокировался)
`cat fifo` - прочитали значение и отдыхаем.

`int *restrict a` - говорим, что это единственный в scope указатель на область памяти и никто не может на него указывать (воздействовать). (нет aliasing)

aliasing (синоним) - ситуация, когда два указателя указывают на одну область памяти.

`restrict` - подсказка компилятору.

Strict aliasing - правила, которые позволяют писать код с большим количеством оптимизаций, которые сделает компилятор.

например во нарушение
```c
int i;
*(float*)(&i) = 4;

char buf[1024]; // к тому же тут память может быть не выровнена
*(int*)buf = 1; // int должен быть выровнен
```