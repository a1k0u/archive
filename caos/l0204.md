# GNU Linux introduction

#### 04.02.23

## Unix-system history

В Bell Labs Кен Томпсан и Денис Ричи запилили Unix, потом AT&T коммерциализировали его. Где-то в Беркли Билл Джой запили подболку программых продуктов, там появилось ядро и все это переросло в BSD. Mac OS является потомком BSD. Затем появился GNU за свободу ПО, чтобы противостоять пропреитарной AT&T.

GNU - GNU is Not Unix :) (рекурсивный акроним)

Linux появился из Minix, которую в своей книги писал Таненбаун.

В 1988 году вышел наконец-то первый стандарт для Unix - POSIX.

portable opertating system interface (x - unix)

AT&T - Single UNIX Specification (SUS) 1994

## File system of Unix

EOF - это не специальный символ, это жизненная ситуация в терминах портала госуслуг (??). То есть считываем какое-то количество байта, а там считвается нуль байт. EOF - ситуация..

правда в конец файла можно что-то записать, пределы файла расширятся

Для работы с файлом нужны идентификаторы - файловые дескрипторы - целое число.

открытые файлы - 0, 1, 2 stdin, stdout, stderr
3 - какой-нибудь somefile.txt

в userspace мы берем буфер, берем дискриптор и считываем в буфер. в кернел спейсе берем дескрипторы.

си помог все файловыедескрипторы обернуть в свой язык

напинаю себе, что у man есть секции для руковтсва

1 - exe программы
2- системные вызовы
3- биб функции

для разделение сущностей с одинаковым названием

`man man`

man 2 read

в errno хранится номер ошибки от последнего системного вызова
константы ошибок лежат в unistd.h

`ssize_t` - знаковый, так как `size_t` беззнаковый

драйвер терминала устроен так, что до нажатия enter (push) программа на STDIN\_ не видит написанное

изменить это можно у терминала

считывание будет до EOF, ситуацию конца файла можно попросить у драйвера терерминала cntrl+D

интересно посмотреть на системные вызовы, которые совершает команды, отправляет параметры и получает. есть команда strace

strace ./mycat

посмотрим как вызовы происходят

strace ./mycat < poem.txt

напрвим в нашу программу файл

теперь создадим файл на два гига и посмотрим как долго он будет его читать

truncate --size=2G somelargefile - оздали файл на 2 гига

time ./mycat < somelargefile > /dev/null

результаты не самые лучшие, почти две секунды на считывание 1Мб

все из-за системных вызовов: на каждый байт мы делаем систмный вызов в нашейй программе - а это программное прерывание, процессор сохраняет состояние исполнения, переключает в ядро, меняет уровень привелегий и начинает обрабаиываеть этот систмный вызов

давайте поправим программу, чтобы она работы немного быстрее

изменим буфер на 100 байт

о чудо 0.020 секунд, быстро!

буфер решает! системных вызовов минимум!

сделаем аналог cat!

все байты, поэтому выход одной программы может являтся входом для другой

echo hello | ./mycat

открыть файл по названию - это системный вызов open

trunc - все файлы пропадут

open возвращает файловый дескриптор, системный вызов opencat

ulimit -n максимум можно открыть столько файловых декрипторов

close закрывает файловый дескриптор, системный вызов close

```c++
int fd = open(name, O_WRONLY | O_CREAT, S_IWUSR | S_IRUSR);
```

lseek - системный вызов, переметка файла

whence - откуда начать SEEK_SET - начало, SEEK_END - конец

системный вызов может вернуть ошибку, поэтому проверяем)

lseek - возвращает смещение от начала записи
pff_t pos = lseek(fd, 0, SEEK_CUR) - относительно текущей позиции сдвинемся на нуль байт

ftruncate(fd, close)

относительно текущей позиции обрежем файл

S_IWUSR - маска для записи юзером 00200
S_IRUSR - маска для чтения юзером 00400 (восьмиричкая цифра, так как три бита)

типа пользователь, группа, другие

в open можно давать режим доступа третьим параметром

stat системный вызов добычи информации про файл

stat file

файл может занимать блоки, блоки могут быть определенного размера

файл может занимать больше, чем кол-во блоков \* на размер, так как в файле могут юыть дыры, но операционная система оптимизирует пространство

файловая система хранит время доступа, последнего изменения и мета инфомрации
 
директория - файловая сущность

символическая ссылка - открое файл, на который ссылкаются `ln -s`
но если мы переименуем родительсккий файл, то символическая ссылка перестанет работать (не будет показывать) - broken link

lrwx------ 

жесткая ссылка - привязываемся к Inode `ln`, правда непонятко кто ссылка, потому что имена равноправные и они ссылкаются на один и тот же файл. тут можно удалять и изменять имя файла

запись на диске имеет отпределенный номер Inode, (stat filename)
при октрытии файла берется Inode и открывает на диске файл

в символической ссылке записывается имя файла, а жесткой - Inode

на inode есть reference count

когда ref count достигает нуля, то ОС удаляет файл


ln -s somefilethatnoexist linkname
echo "some text" >> linkname
тут создастся файл somefilethatnoexist, после того как в сслку засунем соержимое

lstat не подставляет то, что по ссылкой символической

fstat принмает файловых дискриптор 

программа rm  пользуется системный вызовов unlinkat
unlink, unlinkat - delete a name and possibly the file it refers to

opendir получаем DIR *
потом readdir читаем while в struct dirent
и в ней можно взять имя файла
 
чтобы не доставить файлом . .., то решили, что их ужно убрать к чертям
то есть все файлы, начинающиеся с . не выводить. и так появилась конвенция, то .file/.dir скрытый файл или дикертория

так как не все системы имею posix api, то можно пользоваться переносимым Си. функция fopen откроет файл

короче, чуваки решили пошаманить и стандартной библиотеке Си сделали перенос строки унифицированным - \n. А уже файловой системе оно преобразует как нужно в таком формате как нужно на платформе, типа на WINDOWS это CR LF.

"a\nb" такую строку
юникс запишет как "a\nb" без измениний
а в windows "a\r\nb"

короче сломать все проще репы, так как в файлы с разными расширениями может записаться разное количество байт 

как бы вся эта история по режим "w"

если включить бинарную запись, то все становиться лучше
"wb" 

fopen возвращает не файловый дескриптор, так как на разных платформах свое представление файлов
FILE * 

fopen, fprintf, fclosr, fseek

работа с файлами на Си в unix (linux) это обертка на posix api

но в сишке оптимизируются системные вызовы
поток ввода вывода буфферизован

после переполнения буффера или закртия файла, то после проихойдет системный вызов

если не закрыть файл, то буффер пропадет)) вот теперь понятно почему нужно закрывать файл

либо пользуйся системный вызово дружок пирожок

принудительно очистить буффер(синхронизировать с диском) fflush(file)

функция exit вызывается после работы main
 а она все потоки ввода и вывода закрывает
так что можно иногда не ставить fclose, если никто программу не убьет

syscall(SYS_exit, EXIT_SUCCESS) тут уже не вызовется exit, поэтому буффер снова пропадет

в Posix _exit системный вызов
exit - из стандартной библиотеке она fflush и закрывает файл

_exit в Posix unistd.h (появился в каком-то Posix)
-Exit в Си в stdlib.h (появился в C99)

fprintf в stdout буфферизован построчно, то есть до \n. а после выводит его (вызывается системный вызов write)

stderr - вообще не буфферизован

setbuf - управление буффером, лежит в stdio.h

