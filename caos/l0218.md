3       *       2^500
^                 ^
мантисса        ^ показатель степени
                экспонента
Придумаем свое представление вещественных чисел
Возьмем на мантису 4 бита

0 0 0 0

0-15 16 18 20 22 ... 62 64 68 72 ...
сначала инкримент 2, потом по 4
чем больше число, тем меньшая точность

2 ^ 1 * (1) 0 0 0 1
         ^ типа 18
2 ^ 1 * (1) 0 0 1 0
         ^ типа 20
2 ^ 1 * (1) 1 1 1 1
         ^ типа 62
2 ^ 0b10 * (1) 0 0 0 0 
            ^ типа 64
от 0 до 15 мы подразумевали, что в скобках 0

2 ^ 0b1110 * (1) 1 1 1 1 
              ^ максимальное представимое конечное число

2 ^ 0b1111 * (1) 0 0 0 0 
              ^ бесконечное число

2 ^ 0b1111 * (1) 1 0 1 0 
              ^ NaN, если продолжить увеличивать мантису, когда показатель 0b1111

Округление к ближайшему четному

-1 ^ S * 2 ^ E * M 
(два разных нуля, в равнении нужно учитывать)

денормализованные числа - близкие к нулю
нормализовынные - подальше от нуля

сравнение (как целочисленное)
нет ассоциалтивности из-за округления

(3.14 + 1e10) - 1e10 = 0
3.14 + (1e10 - 1e10) = 3.14
замкнутая группа? нет

int -> double нет потери точности, если сконвертировать назад в int
int -> float будет округление

double/float -> int округлению в сторону нуля, обрасываем хвост дробной части

при сложении меньшая экспонента приводится к большей

учет баеса? баес на 127, чтобы положить в показатель степени 0 двойки, в битовом представлении записаывается 127 в части экспоненты

Про то как числа расположены:
![](./img/1.jpg)

![](./img/2.jpg)

немного про баеса (экспоненту отрицательную и положительную) и структуру числа  (float)
![](./img/3.jpg)

просто записали число, где показываем пример, как 129 превратилось в степень 2 (картинка ранее показывала, что нужно вычесть 127) и как писать мантису (младшие нули откидываются)
![](./img/4.jpg)

перевод записанного в память числа в десятичный вид
![](./img/5.jpg)

некоторые числа нельзя прдставить двоично
![](./img/6.jpg)

поэтому такие число и записываются странно
![](./img/7.jpg)

из-за такой неточности у нас и появляются такие проблемы

в мантисе очень сильно сдвигают биты (ну как в физике, чтобы один знак остался в целой части)

![](./img/8.jpg)

union -структура, только в ней члены занимают одну и ту же память
union {
    float f 
    unsigned u
} uf

будем смотреть на float и целое число, как на одно и тоже
scanf("%f", uf.f)

![](./img/9.jpg)

посмотрим как число лежит в памяти
![](./img/10.jpg)

в стандартной библиотеке есть такие штучки (math.h)
![](./img/11.jpg)

scanf умеет читать бесконечное значение
nan он тоже умеет читать (но какой-то определенный nan)

как процессор работает с такими числами?
изначально процессор не умел с ними работать, поэтому ставили отдельный сопроцессор

потом в intel появлялись расширения
сейчас все отдано AVX-512

в SSE изначально добавили XMM0-31 (128 бит)
потом прикрутили YMM0-31 (256 битный)
в AVX-512 ZMM0-31 (512 бит)

это все расширение предыдущих, короче накрутили легаси, расширив с 127 до 512 бит

packed - что в 128 битах лежит два double значения
MOVAPD - для выровняной памяти (aligned) в одном бтольшом регистре
если не так, то MOVUPD (unaligned)

при входе в функцию стек должен быть выровнян на 16 байт, так принято в gcc

это для того чтобы, если нам захочется использовать иструкции из SEE или AVX

все для этого!)

addpd сложить два double xmm1, xmm2/m128

что делать если в памяти лежит отдельный floating point value а мы хоти положить в регистр xmm?

для этого есть семейство инструкций MOVSS 
так можно положить 32 битную инструкцию

HADDPD - horizontal add горизонтальное суммирование

```C
int main() {
    float f[32] = {0.0f};
    size_t i = 0;
    while (scanf("%f", &f[i]) == 1) {
        i++;
    }

    float result = 0.0f;
    for (int j = 0; j < 32; j++) {
        result += f[j];
    }

    printf("%f\n", result);
}
```

objdump -d programm посмотрим на её вид в 32 бита

не факт, что в 32 битном режиме будет доступен SEE, поэтому будут для совместимости спользоваться старинные инструкции из x86 (flds, fstps, fadds)

на 64 битной архитектуре будут уже movss

![](./img/12.png)
![](./img/13.png)

`pxor %xmm2, %xmm2`
cvtss2sd - ...
movq quad word (8 байт, четверное слово) 

-O2 написать такой флаг оптимизации, то там что-то гениальное происходит с asm кодом
меньше движений между числами и памятью

-mavx сказать компилятору, что есть процессор, поддерживающий инструкции AVX

чтобы от SSE перейти AVX-512

Kahan summation algoritm суммирование float с накоплением ошибки для увеличения точности

джейссончики можно парсить быстрее с avx-512))
реально можно!

засчет векторных инструкций

при парсинге нужно найти следующий подобный символ ({, }, ", ", .. ). avx операции дают ускоренную возможность классифицировать символы


http://cs.mipt.ru/wp/wp-content/uploads/2016/02/%D0%94%D0%A122%D0%B203-%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81-%D1%82%D0%BE%D1%87%D0%BA%D0%BE%D0%B8%CC%86.pdf

тут ясно как считают bias:

2^{k - 1} - 1, где k - количество бит под экспоненту

да и про алгебру там сказано, неплохой такой summary
