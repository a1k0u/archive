Memory mapped IO - одно адресное пространство

Port mapped IO - собственная отдельная адресация
VGA использует оба способа ввода и вывода


Загрузка с диска:
MBR (master boot record 512 байт) - преполагается, что в эту загрузучную запись полжат программу,
которая найдет на ЖД ядро ОС и загрузит в память ядро.

.code16 генирация бля 16 битный иструкций (для написания загрузочной иструкции)

hlt - остановится и ничего не делать (команда ассемблера)

-ffreestanding - работа без ОС
когда мы запускаем gcc, то ожидаем hosted реализацию - ОС, стандартную библиотеку СИ (memcpy, memset) оптимизации
короче говоря, у нас него нет

во ffreestanding нет main

int main() // hosted : libc call mains

x86_64-linux-gnu-readelf -h kernel.bin

memory map
-Ttext 0x1000 начинается секция с x1000 (usable memoty)

крос компиляция - сборка для другого компьютера

у нас есть общая шина (system bus) 

control bus управляющая
address адресная
data для передачи данных

процессор выставляет данные, память это видет, на линейках памяти выставляет значение "прочитано из памяти"

адреса ввода вывода называет портами (другая адресация)

cpu на котрольной шине ставит запрос на IO и там портик передаем, читаем или записываем бла бла

 in - input from Port

 out - output to port

 -serial mon:stdio выводить с порта в stdout

bios читает mbr  c 0x7с00 (конвенция биос)
--oformat=binary никаких elf только мясо только код

gdb server (crazyyyyy)

bios предает загрузчику номер диска с которого прочитал в dl

процессор запускается в 16 битном режиме? традиция, совместимость

перед запуском ядра нужно переключится на 32 битный режим (для того, чтобы весети компьютер из режима совместимости)

таблица дескрипторов
сегмент кода cs (exetable)
сегмент данных ds (writable)
сегмент .. es
секмент стека ss

gdt global descriptor table
дескриптор

Сегментная адресация памяти — схема логической адресации памяти компьютера в архитектуре x86. Линейный адрес конкретной ячейки памяти, который в некоторых режимах работы процессора будет совпадать с физическим адресом, делится на две части: сегмент и смещение. Сегментом называется условно выделенная область адресного пространства определённого размера, а смещением — адрес ячейки памяти относительно начала сегмента. Базой сегмента называется линейный адрес (адрес относительно всего объёма памяти), который указывает на начало сегмента в адресном пространстве. В результате получается сегментный (логический) адрес, который соответствует линейному адресу база сегмента+смещение и который выставляется процессором на шину адреса.

Селектором называется число (в x86 — 16-битное), однозначно определяющее сегмент. Селектор загружается в сегментные регистры. 

Дескриптор сегмента (в архитектуре x86) — служебная структура в памяти, которая определяет сегмент. Длина дескриптора равна 8 байт.

в 32 битной системе сегмент дата и кода совпадают и простираются от 0 до 2^32 - 1, только имеют разные атрибуты
code- исполняемые и чтение
data - записываемый

cr0 установив младший бит, устанавливается защищенный режим

ljmp - long jump - load cs and eip
биты доступа написаны компанией интел

jmp . - forever loop

x86_64-linux-gnu-readelf -l kernel.bin смотрим секции


_start - default entery point for ELF

hexdump'ом можно проверить как лег bootloader в образ и код ядра

vga visual graphic array