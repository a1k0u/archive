Мультиплексирование - обработка многих соединений.

Сделаем сервер netcat `nc -lu 31337` принимающий UDP пакеты. И сделаем клиента `nc -u localhost 31337`. Откроем программу wireshark, в которой посмотрим, что у нас гуляет по сети.

Зададим фильтр udp.port == 31337, чтобы видеть интересующие нас пакеты. На канальном уровне могут лежать вырожденные данные из-за ВПН, поэтому посмотрим, что находится на уровне IP (Internet Protocol). Wireshark отменитит байты, которые относится к протоколо IP. Там будут написаны Dst и Src, protocol, длина пакета, time to live - пакеты могут ходить по кругу из-за неправильной настройки, поэтому есть поле, которое говорит, сколько ключевых точек он может пройти, если больше - на помойку, каждый маршрузизатор уменьшает его на единицу. 

Можно по ttl (time to live) понять маршрут, просто увеличивая от 1 ttl. Это может сделать программа `traceroute somesite` (увеличивает Hop Limit).

Time to live (TTL), Hop Limit, в вычислительной технике и компьютерных сетях — предельный период времени или число итераций или переходов, которые набор данных (пакет) может осуществить (прожить) до своего исчезновения.

Перейдем к транспортному уровню, там будет: source port, destination port и checksum.

Дальше payload.

По пути можем потеряться, продублироваться, в разном порядке прийти.. нам бы наладить канал и воспользоваться TCP.

`nc -l 31337` - TCP сервер
В случае TCP сначала происходит соединение перед оправкой payload. Что-то про флаги, сегменты tcp..

src ->[SYN]
[SYN, ACK]<- dst
src -> [ACK]
теперь соединение считается готовым, договорились о соединении (пройдут сегменты и подтверждение о их получении)

src ->[PSH, ACK] отправляем кусочек данных

tcp A (отпраляем много байт) -> B (примит их и соберет воедино, ничего не потеряв, но нам бы подтверждение сколько он принял [до какой позиции])

ACK 4 - получатель должен получить все байты до 4 позиции, отправитель будет знать об этом.

То есть пакеты могут перепутаться, но получатель их правильно запишет. Но ответ он не отправит, так как не было первых байт. Со стороны отправитлея будет предположена идея, что все затерялось. И он отправит ещё раз, в случае удачи отправитель получит ACK n. Отправка байт может начаться с последнего подтвержденного места. Дублирование на получателе можно увидеть по Seq.

Окно - размер данных, которые можно отослать без подтверждения.

connect при tcp как раз это и делает (3 запроса syn. syn ack, ack).

Флаг FIN - закрываем соединение, запрос в обе стороны, но можно и закрыть в одно сторону: просто слушаем, но читаем значение.

Флаг RST со стороны сервера (мы клиент) - на этом порту никто не сидит (не слушает), поэтому соединения не будет.

Вмешаться в разговор от лица пользователя в tcp соединения мешает acknowledment number (который выбирается большим случайным числом), но если мы маршрутизатор, то ОК, число то мы видим.. можно так байтики кому-то свои досылать и может никто не заметит!

Атака: отправили большое количество SYN пакетов с рандомными адресами, портами. Так мы забиваем очередь, в которой он пытается сделать безуспешное соединение, а реальных клиентов обрабатывает медленно или вообще не трогает. SYN Flat 

SYN-флуд — одна из разновидностей сетевых атак типа отказ от обслуживания, которая заключается в отправке большого количества SYN-запросов (запросов на подключение по протоколу TCP) в достаточно короткий срок.

SYN-cookies - защита от этого, не хранит все соединения, а отпраляет чиселко?

https://ru.wikipedia.org/wiki/SYN-%D1%84%D0%BB%D1%83%D0%B4
https://ru.wikipedia.org/wiki/SYN_cookies
https://ru.wikipedia.org/wiki/Time_to_live

System V Unix - классно звучит.
Рассмотрим системные вызовы select, poll, epoll.

Select работает с множеством файловых дескрипторов.

FD_SET - добавление файлового дескриптора в множества.

вызов select блокируется до тех пор, пока не найдется дескриптор, по которому можно писать или читать. Есть и таймаут для select.

int nfds - максимальный файловый дескриптор + 1.
Это оптимизация для ядра, чтобы по битовой маске долго не гулять и не копировать.

select оставляет 1 на тех дескрипторах, которые готовы к чтению/записи, а в остальных 0, поэтому select портит исходные множества.

pselect - системный вызов, который ещё и маску сигналов меняет, чтоооооо...

The  pselect()  system  call allows an application to safely wait until either a file descriptor becomes ready or until a signal is caught.

poll - это про BSD
select - про System V Unix

```c
struct pollfd {
    int fd;
    short events; // маска событий, которые нас истересуют POLLIN, POLLOUT..
    short revents; // после poll(...) нам сюда запишут, что можно сделать с дескриптором
}
```

Хотим избежать неэффективности с копированием на ядро! Epoll хранит уже список в ядре, добавление и изменение происходит через системные вызовы.

int epoll_create1(0); 
epoll_ctl(int epfd, int op, int fd, struct epoll_event *event) - операция с дескриптором на множестве.

epoll_wait - ожидание с записью событий в массив events.

epoll может сам удалить файловых дескриптор?! EPOLL_EXEC?

Сделаем echo-сервер, но нужно учесть, что мы можем заблокироваться на write, так как получатель мог не получить данные/не подтвердил их получение. Нужно делать буффиризацию на запись! И флаг EPOLLOUT поставить, чтобы отправить тем, кто готов получать данные.

Проблема! Ядру нужно убедиться, что  мы прочитали данные, которые нам пришли, поэтому если мы их недочитали, то он снова нам предложит это сделать. Хочется, чтобы все было событийно-ориентированно. network -> epoll_wait. Договоримся с ядром, что мы будем вычитывать все, пока все данные не закончатся, а потом блокировка по epoll_wait.

Раньше все было level triggred [xxxxx    ] и оставшиеся данные (которые вернутся на следующем epoll_wait), а теперь будет [xxxxxYYYY] (edge triggered) (типа точно вычитали, ждем другие и блокируемся по epoll).

Но тут проблема, раз мы хотим все вычитать, то read должен отдать все байты, а байтов может быть ровно по размер буффера -> блокировка при следующем read.

O_NONBLOCK, если в файловом дескрипторе (сокете) нет данных, то вызов read не блокирующий. Если там пусто и мы вызвали read, то вернется ошибка EAGAIN или EWOULDBLOCK.

системный вызов accept4 (+ `#define _GNU_SOURCE`) такой же, что accept, но возвращает неблокирующий дескриптор сразу.

struct epoll_event нужно поставить EPOLLET - edge triggred.  

epoll_ctl - под капотом красно-черное дерево с log временем.

EPOLLONESHOT - чтобы один поток забирал данные с epoll_wait, так мы экономим cpu.

shutdown - закрыть одну сторону сокету (на запись, на чтение или на все).

unix - sockets for local interprocess communication
man 7 unix, AF_UNIX

socketpair - сокет в виде pipe

MSG_MORE (udp), TCP_CORK (tcp) - ядро не торопись сразу отправлять пакет, сейчас я докидаю и отправляй. Мы строим эффективный размер, чтобы снизить нагрузку по заголовкам.

tcp_authcorking - уже есть в последних версиях линукс.

http/1 - tcp?
http/2,3 - udp?

