/proc - все процессы

Прогамму, которую мы написали и запустили называется -  процессом

процесс - запись во внутренних ресурсах ядра, планирование, файловые дескрипторы, виртуальная память

ps aux | less - наши процессы
у каждого процесса есть PID process id
процесс выполняется от какого-то польщователя, у процесса есть статус

частые статусы:
- s (stoped) одидает ввода, чем-то заблокирован в системном вызове и не готов выполнятся
- r (run) - процесс выполняется
- I что-то там с ядром

что есть у процесса? собственная виртуальная память (набор отображений), таблица файловых дескрипторов, что-то ещё на что мы не смотрели

как породить новый процесс? в классическом юниксе породить новый процесс - системный вызов fork. Он создает процесс в точности такой же, какой работает. копируется со всем.

#include <sys/types.h>
#include <unistd.h>
pid_f fork(void)

какждый процесс живет в своей виртуальной памяти

`getpid()` - pid текущего процесса

```c
int main() {
    fork();
    printf("Hello world from %d\n", getpid());
}
```

child процесс не начинает выполнение программы с самого начала.
доказетльсвтом этому (поставить принт перед fork)

`getppid()` - pid родителя

Сделаем глобальную переменную, значение которой нуль. В кажом из процессов инкроментируем значение этой переменной. Если бы переменная была бы общей у обоих процессов, то значение было бы 2. Но это не так, результат 1. Но адрес переменных один и тот же (виртуальный), значения у них разные и не зависимые. Как же сделать это эффективно в ОС - механизм copy-on-write

```c
...

int x = 0;

int main() {
    ...
    fork();
    x += getpid();
    ...
    printf("x=%d, &x=%p\n", x, &x);
    ...
}
```

глобальная переменная - .data. Секция .data - read, write. Вот мы хотим, чтобы они были rw. В момент fork значения становятся read-only для экономия памяти. При попытке изменить ro происходит page fault - копирование физической памяти и делает её read write. ТО есть это все copy-on-write.

Системный вызов fork в родительский процесс PID дочернего процесса, а дочерный процесс - 0. (pid не бывает нулевым) -1 при ошибке.

```c
pid_f res = fork();
if (res == -1) {
    // error
}

if (res) {
    // parent
} else {
    // child
}
```

Определен ли порядок выполнения между ребенком и родителем? Процессы никак не синхронизированны друг с другом. Попробуем запустить гонку.

```c
...
for (x = 0; x < 100; ++x) {
    printf("%d: %d\n", getpid(), x);
}
...
```

В этом экспиременте примерно последовательно начали все делать. Но они никак не синхронизированы. Зачем нам это все нужно? Зачем нам нужно, чтобы в системе много процессов? Для пользователей, чтобы они могли пользоваться несколькими программи.

Если parent завершает свою работу, то child прекращает работать? Проведем эксперемент! Пусть ребенок поспит, чтобы родитель успел все напечатать. Но произошло интереснее! Если родительский процесс умер, то мы возвращаемся в условный bash. Shell спокойно начал работать, ему не интересно, что там случилось с потомками. А потомки поспали, а затем что-то вывели. 

Родитель - заканчивает работу, а потомок продолжает свою работу.
Если stdout буфферизовался (stdout). Оба ли процессора сбросят его? Буффер копируется со всем остальной памятью.

Parent может узнать чем завершился child. Есть системный вызов wait. Будем мы ждать только наших потомков (тех кого мы форкнули).

`pid_t wait(int *wstatus)`
`pid_t reaped = wait(&status);`

Статус получился какой-то странный  и никак не связанный с return из main. Это больше информации, чем просто return. Помимо в int есть ещё дополнительная информация. Есть макросы, которые по значению wstatus, чтобы узнать как мы вышли. `WIFEXITED` - вышли из main или exit, если до то можем знать статус `WEXITSTATUS`.

```c
if (WIFEIXTED(status)) {
    printf("... - %d\n", WEXITSTATUS(status));
}
```

Если бы мы вызвали wait, когда нет детей, то мы бы просто вышли.

Процессы при смерти не сразу удаляются из таблицы процессов. Процесс который погиб, но который не wait - переходит в состояние зомби. Он как бы умер, но ещё не исчез. Ребенок процесс будет с меткой defunct - не функционирующий, чей pid нельзя ещё переиспользовать. Он будет ждать родительского процесса (пока он выполнит wait). ОС будет держать зомби, пока жив родитель. Пока есть кому сообщать о смерте, то он будет зомби. Если родительский процесс завершится или его убьют, то информация о зомби не нужна. 

PID 1 - процесс init, который запускает процессы из user space. 

В классическом случае, если процесс завершился и его родитель не подождал, то ОС назначает ему нового родителя - init. 

В современной Ubuntu, pid - умеет демон systemd.

Если у нас несколько детей, кого выбирает `wait` - любого в классическом понимании. `waitpid` - ждет конкретного.

после pause(); можно убить сразу оба процесса. В ОС есть понятие - группы процессов. Когда мы убиваем эти процессы через терминал, то мы хотим убить сразу всех. Таким процессам назначается одинаковая группа (лирическое отступление).

waitpid(result, &status, WNOHANG)
вместо result -1 - ждать любого потомка
wnohang - return immediatly if no child has exist.

```c
result = fork();
if (result == 0) {
    sleep(3);
} else {
    while (1) {
        sleep(1);
        pid_t reaped = waitpid(result, &status, WNOHANG);
        if (reaped <= 0) {
            continue;
        } else {
            printf("%d\n", reaped);
            break;
        }
    }   
}
```

родительский и дочеркий печатают в один stdout, потому что действительно все скопировалось. А что с файлами? Как взпимодействуют с файлами дочерний и родительский процесс?

Мы умеем открывать файлы с помощью сситемного вызова open и получаем файловый дескриптор. На самом деле open создает две сущности - ещё file description. 

То есть файловый дескриптор (число) - это индекс в таблицу в ядре, из которой ссылки ведут на file description (путь, inode, reference count [типа ссылки на объект, при нуле struct file погибает (close)]). Табличка файловых дескрипторов у каждого процесса своя, а сами struct file - общие.

struct file (позиция записи в файле, таблица виртуальных методов).

Что происходит с этими структурами при:
- fork(); 
  - со struct file произойдет ничего, кроме того, что увеличится f_count.
  - со struct fdtable произойдет копирование
- close(); 
  - --f_count, если f_count == 0, то file description закрывается и удаляется
- lseek(); 
  - f_pos в file_description
- read() write()
  - будет двигать общую позицию чтения-запись (f_pos) у file description

Что про чтение из двух процессов? Data races? Атомарность? Не получится ли так, что из разных процессов вы пишем или читаем в один и тот же файл и у нас позциия чтения и записи не согласуется.

- Атомарность (относительно класса наблюбателей) - свойство операции
- Наблюдатель не может "поймать момент", когда атомарная операция будет в сереине выполнения в промжуточном состоянии
- Для наблюдателя автомарная операция или не началась, или уже закончилась

O_EXCL - не создает файл если он уже создать (flag in open system call).

- В Unix если одноврменно несоколь процессов работают с копиями одного и того же файлового дескриптора или с одним и тем же файлом, и операции чтения, и операции записи разрешены без ограничений. ОС никак не помогает разрешать конфликты.

- Процессы должны сами согласовать свое поведение, чтобы избежать порчи данных.

- Варианты: флаг O_APPEND, рекомендательные блокировки, обязательные блокировки

Флаг O_APPEND
- Если при открытии файла задан флаг O_APPEND
- При кажой записи в файл указатель текущей позиции сначала перемещается в конец файла
- Затем выполняется запись файл
- Эти два действия - атомарны

POSIX не гарантирует атомарности чтения/запими при работе с файлами.
Реально Linux записывает/считывает данные небольшого размера (1 кибибайт) атомарно, то есть при записи данные двух процессов не перемешаются. В современных версиях Linux (~2014) чтение/запись и изменение значения текущей позиции в совокупности атомарны. 

exec - execute a file, системные вызовы, чтобы выполнить другую программу. 

```c
int main(int argc, char *argv[]) {
    // echo - нулевой аргумент
    execl("/bin/echo", "echo", "hello", "world", NULL)
} // NULL нужен чтобы показать - аргументов нет. 
```

у кого l в суффиксе - аргементы фукнции
v - массив аргументов

Если execv отоработал нормально, то он ничего не возвращает, так как программа завершилась. После exec ничего не работает, так как мы переключились на другую программу.

#! - she(какое-то название #) bang(типа взрыв)

бит доступа x - можем проходит в директорию
r - можем получить список содержимого

У каждого процесса есть текущая рабочая директория - getcwd, её можно поменять - chdir. Директория помогает разрешать относительные имена. 

cd - встроенная команда shell из-за не логичности делигирования своей задачи.

Запустим прогрмму в отдельном процессе, совместив fork и exec.

```c
int main(int argc, char *argv[]) {
    pid_t child = fork();
    if (child > 0) {
        execv(argv[1], argv + 2);
        return 127; // если exevc не выполнился
    }

    // давайте выясним как отработал дочерний процесс

    int status;
    wait(&status);
    if (WIFEXITED(status)) {
        printf("exit code: %d\n", WEXITSTATUS(status));
    }
    // bash
    // \_ ./run ./run run /bin/sleep sleep 100
    //   \_  run /bin/sleep sleep 100
    //     \_  sleep 100
}
```

Мы можем управлять переменными окружения! Они хрансятся в массиве строк char**. (execpv)

execve запускается все возможные пути в PATH.

В shell мы умеем переводить ввод и вывод, например, cat > somefile.txt.

```c
int fd = open("somefile.txt". O_WRONLY | O_CREATE | O_TRUNC, 0600);
// было бы неплохо проверить fd >= 0
dup2(fd, STDOUT_FILENO); // перенаправляем вывод
close(fd);
chdir("...."); // тут директорию можем поменять перед запуском новой программы
execvp(argv[1], argv + 2);
```

dup,  dup2, dup3 - duplicate a file descriptor;

exec оставляет нас в том же самом процессе с тем же самым pid, только замещает его тело и благодаря этому у нас есть взаимотношение родитель-ребенок.

mmap() - сделаем 1 Мб аннонимной памяти и будем пользоваться из родительского и дочернего класса.

```c
int *array = mmap(NULL, 1<<20, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMUS, -1, 0); // разделяемая память
array[0] = 3;
```

getchar_unlocked - считывает, если другие потоки не пытаются залезть в файловый дескрипто. Файловые дескрипторы есть в POSIX, но нет в языке Си. Добыть файловый дескриптор fileno, а наоборот fd -> FILE*. Правда не понтяно, что произойдет с буффером, чтобы ничего не перемешалось.

return -> exit -> сброс буфера. Если exec не сработал, то мы должны завершить дочерний процесс без внешних эффектов (например сброс буфера и т.д.), изанчально у нас return стоял, который вносит side effect. Cистемный вызов _exit() при котором не будет side effects и buffer error (`man exit`).  