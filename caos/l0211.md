`pidof cat` получим идентификатор запущенной программы

ядро линукс дает виртуальную файловую систему /proc, в которой про каждый процесс (запущенную программу) рассказывает некоторую информацию

в maps
первая коллонка - доступнеы адреса (диапозон)
/usr/bin/cat - туда загружена программа

вторая колонка - что можно делать с этим участком памяти

типа в случае cat
1 участок - elf
2 участок - исполняемый код, секция .text
дальше вероятно .read only data
потом rw участок .data
там лежит stack
да и libc (стандартная библиотека)

head - участок памяти, откуда аллоцируется память

механизм страниц памяти у процессора для отображения на физическую память

1 страница 4Кiб?

mmap - систменый вызов

flags в mmap
MAP_SHARED
MAP_PRIVATE - бит `p` в битах доступа

char *ptr = mmap(NULL [ОС сама найдет виртуальное простанство], filesize [нашли lseek'ом], PROT_READ [только читаем файл], MAP_SHARED [тут можно и private поставить, но так как вы читаем, то пофиг], fd, 0 [нулевую смещение, то есть с адреса, который отдаст mmap])

ptr == MAP_FAILED указатель со всеми единицами (-1)

pause(); системный вызов, чтобы остановить программу

так как есть \0, то нам повезло? откуда взялся он. хз, мы же печатали текс из файла

можем зайти в proc и заценить красоту
s - shared в битах доступа

fc:02 типа пример - id устройства
а потом node файла

размер выделятся минимум одна страница, не меньше
в случае лектора 4 кб

так текст маленький, то все свободное место заполнилось нулями, вот откуда взялся нулевой байтик и printf не стал все печатать

на linux x86 - страница 4кб
но для совместимости у системы можно спросить какой размер

если *ptr = 'x'; то нас кокнут, так отображение только на чтение

если открыть файл, который открыт только на чтение, а мы его за ммапим на чтение и запись, то он от такой наглости закроется
(файл изначально map_shared - тут данные записывались в сам файл)

а если сделать его map_private (тут они не будут записываться)?
все сработало!!! 


откроем файл на чтение и запись
O_RDWR на чтение и запись открытили
и вдобавок MAP_SHARED
 
эксперемент: если поменять значение, да и даже убить программу, то файл измениться. А вообще если убить программу, то она могла бы не записать его на диск

вообще правильно синхронизировать отображение в таком случае, но нам повезло, что это произошло без доп указаний

msync(...)

munmap - принимает какой-то отображенный адрес в виртуальной памяти и пытается удалить его с точки зрения структур данных ОС

можно частично удалить? но там удалить только целую страницу можно удалить. 

что делать ОС, если одна программа запущена два раза? она будет отображена в свою виртуальную память

как мы думаем?  ну короче ОС кладет на одну и тоже страницу одну программу запущенную одновременно
но при copy on write, когда процессы начинают работать со своей памятью
мы экономим память в тех местах, где она не меняется

если ОС нужна оперативка для нусущных вещей, тогда у cat будут удалены страницы для отображения. а где-то останется память, что существовала такое существо, тогда с диска загрузимся

echo "some text" >> binary_file, система даст ошибку, так как бинарник в работе. Linux ругается

swap там лежат (на диске) редко используемые страницы оперативной памяти (гряные старницы)

можно выделить память, в файловый дескриптор положим -1
и MAP_ANONUMYS???

как организовать отдельные библиотеки программного кода, чтобы их совместно использовали разные процессы.

ldd - print shared object dependencies

динамический загрузчик занимается всякими интересными штуками, чтобы стандартную библиотеку раздать всем

.so - shared object

помимо секции load, есть секция dynamic
interp - перед выполнением скции в load (вход в entery point)

как требования к кода разделяемых библиотек?
- перемещаемый код, нет фиксированый адресов в памяти

gcc -m32 -shared -fPIC -o some.so

nm -D some.o 
можно узнать что нужно и т.л

nm -D /lib32/libc.so.6 | less

когда программа будет загружаться: ядро посмотрит на секцию INTERP, запустим динамический загрузчик ld-linux.so.2

динамический загрузчик посмотрит на секцию Dymnamic обнаружит требования, найдет файл, загрузит в дресное пространство

но кто подставляет адрес нужных функция, когда мы хотим её вызвать?

plt?
PIC?
fpie position independent executable
 
аху.т можно в RT компоноваться с другим кодом, чтобы запскать неопределнные функции. для этого есть API

handle = void *dlopen(const char *filename, int flags)

void *dlsym(void *handle, const char *symbol)
можем найти некоторый символ

